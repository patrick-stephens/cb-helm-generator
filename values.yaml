# Couchbase Operator Chart Values
# AntiAffinity forces the Operator to schedule different Couchbase server pods
# on different Kubernetes nodes.  Anti-affinity reduces the likelihood of
# unrecoverable failure in the event of a node issue.  Use of anti-affinity is
# highly recommended for production clusters.
antiAffinity: null
# AutoResourceAllocation populates pod resource requests based on the services
# running on that pod.  When enabled, this feature will calculate the memory
# request as the total of service allocations defined in `spec.cluster`, plus an
# overhead defined by `spec.autoResourceAllocation.overheadPercent`.Changing
# individual allocations for a service will cause a cluster upgrade as
# allocations are modified in the underlying pods.  This field also allows
# default pod CPU requests and limits to be applied. All resource allocations
# can be overridden by explcitly configuring them in the
# `spec.servers.resources` field.
autoResourceAllocation:
  # CPULimits automatically populates the CPU limits across all Couchbase server
  # pods.  This field defaults to "4" CPUs.  Explicitly specifying the CPU limit
  # for a particular server class will override this value.  More info:
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-
  # containers/#resource-units-in-kubernetes
  cpuLimits: '4'
  # CPURequests automatically populates the CPU requests across all Couchbase
  # server pods.  The default vaule of "2", is the minimum recommended number of
  # CPUs required to run Couchbase Server.  Explicitly specifying the CPU
  # request for a particular server class will override this value. More info:
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-
  # containers/#resource-units-in-kubernetes
  cpuRequests: '2'
  # Enabled defines whether auto-resource allocation is enabled.
  enabled: null
  # OverheadPercent defines the amount of memory above that required for
  # individual services on a pod.  For Couchbase Server this should be
  # approximately 25%.
  overheadPercent: 25
# AutoscaleStabilizationPeriod defines how long after a rebalance the
# corresponding HorizontalPodAutoscaler should remain in maintenance mode.
# During maintenance mode all autoscaling is disabled since every
# HorizontalPodAutoscaler associated with the cluster becomes inactive. Since
# certain metrics can be unpredictable when Couchbase is rebalancing or
# upgrading, setting a stabilization period helps to prevent scaling
# recommendations from the HorizontalPodAutoscaler for a provided period of
# time.   Values must be a valid Kubernetes duration of 0s or higher:
# https://golang.org/pkg/time/#ParseDuration A value of 0, puts the cluster in
# maintenance mode during rebalance but immediately exits this mode once the
# rebalance has completed. When undefined, the HPA is never put into maintenance
# mode during rebalance.
autoscaleStabilizationPeriod: null
# Backup defines whether the Operator should manage automated backups, and how
# to lookup backup resources.
backup:
  # The Backup Image to run on backup pods
  image: null
  # ImagePullSecrets allow you to use an image from private repositories and
  # non-dockerhub ones.
  imagePullSecrets:
    # Name of the referent. More info:
    # https://kubernetes.io/docs/concepts/overview/working-with-
    # objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    name: null
  # Managed defines whether backups are managed by us or the clients.
  managed: null
  # NodeSelector defines which nodes to constrain the pods that run any backup
  # operations to
  nodeSelector: null
  # Resources is the resource requirements for the backup container. Will be
  # populated by defaults if not specified.
  resources:
    # Limits describes the maximum amount of compute resources allowed. More
    # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
    # resources-container/
    limits: null
    # Requests describes the minimum amount of compute resources required. If
    # Requests is omitted for a container, it defaults to Limits if that is
    # explicitly specified, otherwise to an implementation-defined value. More
    # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
    # resources-container/
    requests: null
  # S3Secret contains the region and credentials for operating backups in S3
  s3Secret: null
  # Selector allows CouchbaseBackup and CouchbaseBackupRestore resources to be
  # filtered based on labels.
  selector:
    # matchExpressions is a list of label selector requirements. The
    # requirements are ANDed.
    matchExpressions:
      # key is the label key that the selector applies to.
      key: null
      # operator represents a key's relationship to a set of values. Valid
      # operators are In, NotIn, Exists and DoesNotExist.
      operator: null
      # values is an array of string values. If the operator is In or NotIn, the
      # values array must be non-empty. If the operator is Exists or
      # DoesNotExist, the values array must be empty. This array is replaced
      # during a strategic merge patch.
      values: null
    # matchLabels is a map of {key,value} pairs. A single {key,value} in the
    # matchLabels map is equivalent to an element of matchExpressions, whose key
    # field is "key", the operator is "In", and the values array contains only
    # "value". The requirements are ANDed.
    matchLabels: null
  # The Service Account to run backup (and restore) pods under. Without this
  # backup pods will not be able to update status
  serviceAccountName: null
  # Tolerations specifies all backup pod tolerations.
  tolerations:
    # Effect indicates the taint effect to match. Empty means match all taint
    # effects. When specified, allowed values are NoSchedule, PreferNoSchedule
    # and NoExecute.
    effect: null
    # Key is the taint key that the toleration applies to. Empty means match all
    # taint keys. If the key is empty, operator must be Exists; this combination
    # means to match all values and all keys.
    key: null
    # Operator represents a key's relationship to the value. Valid operators are
    # Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for
    # value, so that a pod can tolerate all taints of a particular category.
    operator: null
    # TolerationSeconds represents the period of time the toleration (which must
    # be of effect NoExecute, otherwise this field is ignored) tolerates the
    # taint. By default, it is not set, which means tolerate the taint forever
    # (do not evict). Zero and negative values will be treated as 0 (evict
    # immediately) by the system.
    tolerationSeconds: null
    # Value is the taint value the toleration matches to. If the operator is
    # Exists, the value should be empty, otherwise just a regular string.
    value: null
# Buckets defines whether the Operator should manage buckets, and how to lookup
# bucket resources.
buckets:
  # Managed defines whether buckets are managed by us or the clients.
  managed: null
  # Selector is a label selector used to list buckets in the namespace that are
  # managed by the Operator.
  selector:
    # matchExpressions is a list of label selector requirements. The
    # requirements are ANDed.
    matchExpressions:
      # key is the label key that the selector applies to.
      key: null
      # operator represents a key's relationship to a set of values. Valid
      # operators are In, NotIn, Exists and DoesNotExist.
      operator: null
      # values is an array of string values. If the operator is In or NotIn, the
      # values array must be non-empty. If the operator is Exists or
      # DoesNotExist, the values array must be empty. This array is replaced
      # during a strategic merge patch.
      values: null
    # matchLabels is a map of {key,value} pairs. A single {key,value} in the
    # matchLabels map is equivalent to an element of matchExpressions, whose key
    # field is "key", the operator is "In", and the values array contains only
    # "value". The requirements are ANDed.
    matchLabels: null
# ClusterSettings define Couchbase cluster-wide settings such as memory
# allocation, failover characteristics and index settings.
cluster:
  # AnalyticsServiceMemQuota is the amount of memory that should be allocated to
  # the analytics service. This value is per-pod, and only applicable to pods
  # belonging to server classes running the analytics service.  This field must
  # be a quantity greater than or equal to 1Gi.  This field defaults to 1Gi.
  # More info: https://kubernetes.io/docs/concepts/configuration/manage-
  # resources-containers/#resource-units-in-kubernetes
  analyticsServiceMemoryQuota: 1Gi
  # AutoCompaction allows the configuration of auto-compaction, including on
  # what conditions disk space is reclaimed and when it is allowed to run.
  autoCompaction:
    # DatabaseFragmentationThreshold defines triggers for when database
    # compaction should start.
    databaseFragmentationThreshold:
      # Percent is the percentage of disk fragmentation after which to
      # decompaction will be triggered. This field must be in the range 2-100,
      # defaulting to 30.
      percent: 30
      # Size is the amount of disk framentation, that once exceeded, will
      # trigger decompaction. More info:
      # https://kubernetes.io/docs/concepts/configuration/manage-resources-
      # containers/#resource-units-in-kubernetes
      size: null
    # ParallelCompaction controls whether database and view compactions can
    # happen in parallel.
    parallelCompaction: null
    # TimeWindow allows restriction of when compaction can occur.
    timeWindow:
      # AbortCompactionOutsideWindow stops compaction processes when the process
      # moves outside the window.
      abortCompactionOutsideWindow: null
      # End is a wallclock time, in the form HH:MM, when a compaction should
      # stop.
      end: null
      # Start is a wallclock time, in the form HH:MM, when a compaction is
      # permitted to start.
      start: null
    # TombstonePurgeInterval controls how long to wait before purging
    # tombstones. This field must be in the range 1h-1440h, defaulting to 72h.
    # More info:  https://golang.org/pkg/time/#ParseDuration
    tombstonePurgeInterval: 72h
    # ViewFragmentationThreshold defines triggers for when view compaction
    # should start.
    viewFragmentationThreshold:
      # Percent is the percentage of disk fragmentation after which to
      # decompaction will be triggered. This field must be in the range 2-100,
      # defaulting to 30.
      percent: 30
      # Size is the amount of disk framentation, that once exceeded, will
      # trigger decompaction. More info:
      # https://kubernetes.io/docs/concepts/configuration/manage-resources-
      # containers/#resource-units-in-kubernetes
      size: null
  # AutoFailoverMaxCount is the maximum number of automatic failovers Couchbase
  # server will allow before not allowing any more.  This field must be between
  # 1-3, default 3.
  autoFailoverMaxCount: 3
  # AutoFailoverOnDataDiskIssues defines whether Couchbase server should
  # failover a pod if a disk issue was detected.
  autoFailoverOnDataDiskIssues: null
  # AutoFailoverOnDataDiskIssuesTimePeriod defines how long to wait for
  # transient errors before failing over a faulty disk.  This field must be in
  # the range 5-3600s, defaulting to 120s.  More info:
  # https://golang.org/pkg/time/#ParseDuration
  autoFailoverOnDataDiskIssuesTimePeriod: 120s
  # AutoFailoverServerGroup whether to enable failing over a server group.
  autoFailoverServerGroup: null
  # AutoFailoverTimeout defines how long Couchbase server will wait between a
  # pod being witnessed as down, until when it will failover the pod.  Couchbase
  # server will only failover pods if it deems it safe to do so, and not result
  # in data loss.  This field must be in the range 5-3600s, defaulting to 120s.
  # More info:  https://golang.org/pkg/time/#ParseDuration
  autoFailoverTimeout: 120s
  # ClusterName defines the name of the cluster, as displayed in the Couchbase
  # UI. By default, the cluster name is that specified in the CouchbaseCluster
  # resource's metadata.
  clusterName: null
  # Data allows the data service to be configured.
  data:
    # ReaderThreads allows the number of threads used by the data service, per
    # pod, to be altered.  This value must be between 4 and 64 threads, and
    # should only be increased where there are sufficient CPU resources
    # allocated for their use.  If not specified, this defaults to the default
    # value set by Couchbase Server.
    readerThreads: null
    # ReaderThreads allows the number of threads used by the data service, per
    # pod, to be altered.  This setting is especially relevant when using
    # "durable writes", increaing this field will have a large impact on
    # performance.  This value must be between 4 and 64 threads, and should only
    # be increased where there are sufficient CPU resources allocated for their
    # use. If not specified, this defaults to the default value set by Couchbase
    # Server.
    writerThreads: null
  # DataServiceMemQuota is the amount of memory that should be allocated to the
  # data service. This value is per-pod, and only applicable to pods belonging
  # to server classes running the data service.  This field must be a quantity
  # greater than or equal to 256Mi.  This field defaults to 256Mi.  More info:
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-
  # containers/#resource-units-in-kubernetes
  dataServiceMemoryQuota: 256Mi
  # EventingServiceMemQuota is the amount of memory that should be allocated to
  # the eventing service. This value is per-pod, and only applicable to pods
  # belonging to server classes running the eventing service.  This field must
  # be a quantity greater than or equal to 256Mi.  This field defaults to 256Mi.
  # More info: https://kubernetes.io/docs/concepts/configuration/manage-
  # resources-containers/#resource-units-in-kubernetes
  eventingServiceMemoryQuota: 256Mi
  # IndexServiceMemQuota is the amount of memory that should be allocated to the
  # index service. This value is per-pod, and only applicable to pods belonging
  # to server classes running the index service.  This field must be a quantity
  # greater than or equal to 256Mi.  This field defaults to 256Mi.  More info:
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-
  # containers/#resource-units-in-kubernetes
  indexServiceMemoryQuota: 256Mi
  # DEPRECATED - by indexer. The index storage mode to use for secondary
  # indexing.  This field must be one of "memory_optimized" or "plasma",
  # defaulting to "memory_optimized".  This field is immutable and cannot be
  # changed unless there are no server classes running the index service in the
  # cluster.
  indexStorageSetting: memory_optimized
  # Indexer allows the indexer to be configured.
  indexer:
    # LogLevel controls the verbosity of indexer logs.  This field must be one
    # of "silent", "fatal", "error", "warn", "info", "verbose", "timing",
    # "debug" or "trace", defaulting to "info".
    logLevel: info
    # MaxRollbackPoints controls the number of checkpoints that can be rolled
    # back to.  The default is 2, with a minimum of 1.
    maxRollbackPoints: 2
    # MemorySnapshotInterval controls when memory indexes should be snapshotted.
    # This defaults to 200ms, and must be greater than or equal to 1ms.
    memorySnapshotInterval: 200ms
    # StableSnapshotInterval controls when disk indexes should be snapshotted.
    # This defaults to 5s, and must be greater than or equal to 1ms.
    stableSnapshotInterval: 5s
    # StorageMode controls the underlying storage engine for indexes.  Once set
    # it can only be modified if there are no nodes in the cluster running the
    # index service.  The field must be one of "memory_optimized" or "plasma",
    # defaulting to "memory_optimized".
    storageMode: memory_optimized
    # Threads controls the number of processor threads to use for indexing. A
    # value of 0 means 1 per CPU.  This attribute must be greater than or equal
    # to 0, defaulting to 0.
    threads: null
  # Query allows the query service to be configured.
  query:
    # BackfillEnabled allows the query service to backfill.
    backfillEnabled: true
    # TemporarySpace allows the temporary storage used by the query service
    # backfill, per-pod, to be modified.  This field requires `backfillEnabled`
    # to be set to true in order to have any effect.
    temporarySpace: 5Gi
    # TemporarySpaceUnlimited allows the temporary storage used by the query
    # service backfill, per-pod, to be unconstrainend.  This field requires
    # `backfillEnabled` to be set to true in order to have any effect. This
    # field overrides `temporarySpace`.
    temporarySpaceUnlimited: null
  # QueryServiceMemQuota is a dummy field.  By default, Couchbase server
  # provides no memory resource constrints for the query service, so this has no
  # effect on Couchbase server.  It is, however, used when the
  # spec.autoResourceAllocation feature is enabled, and is used to define the
  # amount of memory reserved by the query service for use with Kubernetes
  # resource scheduling.
  queryServiceMemoryQuota: null
  # SearchServiceMemQuota is the amount of memory that should be allocated to
  # the search service. This value is per-pod, and only applicable to pods
  # belonging to server classes running the search service.  This field must be
  # a quantity greater than or equal to 256Mi.  This field defaults to 256Mi.
  # More info: https://kubernetes.io/docs/concepts/configuration/manage-
  # resources-containers/#resource-units-in-kubernetes
  searchServiceMemoryQuota: 256Mi
# EnableOnlineVolumeExpansion enables online expansion of Persistent Volumes.
# You can only expand a PVC if its storage class's "allowVolumeExpansion" field
# is set to true. Additionally, Kubernetes feature
# "ExpandInUsePersistentVolumes" must be enabled in order to expand the volumes
# which are actively bound to Pods. Volumes can only be expanded and not reduced
# to a smaller size. See:
# https://kubernetes.io/docs/concepts/storage/persistent-volumes/#resizing-an-
# in-use-persistentvolumeclaim   If "EnableOnlineVolumeExpansion" is enabled for
# use within an evironment that does not actually support online volume and file
# system expansion then the cluster will fallback to rolling upgrade procedure
# to create a new set of Pods for use with resized Volumes. More info:
# https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-
# persistent-volumes-claims
enableOnlineVolumeExpansion: null
# EnablePreviewScaling enables autoscaling for stateful services and buckets.
# DEPRECATED - This option only exists for backwards compatibility and no longer
# restricts autoscaling to ephemeral services. To be removed in future releases.
enablePreviewScaling: null
# Hibernate is whether to hibernate the cluster.
hibernate: null
# HibernationStrategy defines how to hibernate the cluster.  When Immediate the
# Operator will immediately delete all pods and take no further action until the
# hibernate field is set to false.
hibernationStrategy: null
# Image is the container image name that will be used to launch Couchbase server
# instances.  Updating this field will cause an automatic upgrade of the
# cluster.
image: null
# Logging defines Operator logging options.
logging:
  # Used to manage the audit configuration directly
  audit:
    # The list of event ids to disable for auditing purposes. This is passed to
    # the REST API with no verification by the operator. Refer to the
    # documentation for details:
    # https://docs.couchbase.com/server/current/audit-event-reference/audit-
    # event-reference.html
    disabledEvents: null
    # The list of users to ignore for auditing purposes. This is passed to the
    # REST API with minimal validation it meets an acceptable regex pattern.
    # Refer to the documentation for full details on how to configure this:
    # https://docs.couchbase.com/server/current/manage/manage-security/manage-
    # auditing.html#ignoring-events-by-user
    disabledUsers: null
    # Enabled is a boolean that enables the audit capabilities.
    enabled: null
    # Handle all optional garbage collection (GC) configuration for the audit
    # functionality. This is not part of the audit REST API, it is intended to
    # handle GC automatically for the audit logs. By default the Couchbase
    # Server rotates the audit logs but does not clean up the rotated logs. This
    # is left as an operation for the cluster administrator to manage, the
    # operator allows for us to automate this:
    # https://docs.couchbase.com/server/current/manage/manage-security/manage-
    # auditing.html
    garbageCollection:
      # Provide the sidecar configuration required (if so desired) to
      # automatically clean up audit logs.
      sidecar:
        # The minimum age of rotated log files to remove, defaults to one hour.
        age: 1h
        # Enable this sidecar by setting to true, defaults to being disabled.
        enabled: null
        # Image is the image to be used to run the audit sidecar helper. No
        # validation is carried out as this can be any arbitrary repo and tag.
        image: busybox:1.32.1
        # The interval at which to check for rotated log files to remove,
        # defaults to 20 minutes.
        interval: 20m
        # Resources is the resource requirements for the cleanup container. Will
        # be populated by Kubernetes defaults if not specified.
        resources:
          # Limits describes the maximum amount of compute resources allowed.
          # More info: https://kubernetes.io/docs/concepts/configuration/manage-
          # compute-resources-container/
          limits: null
          # Requests describes the minimum amount of compute resources required.
          # If Requests is omitted for a container, it defaults to Limits if
          # that is explicitly specified, otherwise to an implementation-defined
          # value. More info:
          # https://kubernetes.io/docs/concepts/configuration/manage-compute-
          # resources-container/
          requests: null
    # The interval to optionally rotate the audit log. This is passed to the
    # REST API, see here for details:
    # https://docs.couchbase.com/server/current/manage/manage-security/manage-
    # auditing.html
    rotation:
      # The interval at which to rotate log files, defaults to 15 minutes.
      interval: 15m
      # Size allows the specification of a rotation size for the log, defaults
      # to 20Mi.
      size: 20Mi
  # LogRetentionCount gives the number of persistent log PVCs to keep.
  logRetentionCount: null
  # LogRetentionTime gives the time to keep persistent log PVCs alive for.
  logRetentionTime: null
  # Specification of all logging configuration required to manage the sidecar
  # containers in each pod.
  server:
    # ConfigurationName is the name of the Secret to use holding the logging
    # configuration in the namespace. A Secret is used to ensure we can safely
    # store credentials but this can be populated from plaintext if acceptable
    # too. If it does not exist then one will be created with defaults in the
    # namespace so it can be easily updated whilst running.
    configurationName: fluent-bit-config
    # Enabled is a boolean that enables the logging sidecar container.
    enabled: null
    # A boolean which indicates whether the operator should manage the
    # configuration or not. If omitted then this defaults to true which means
    # the operator will attempt to reconcile it to default values. To use a
    # custom configuration make sure to set this to false.
    manageConfiguration: true
    # Any specific logging sidecar container configuration.
    sidecar:
      # ConfigurationMountPath is the location to mount the ConfigurationName
      # Secret into the image. If another log shipping image is used that needs
      # a different mount then modify this.
      configurationMountPath: /fluent-bit/config/
      # Image is the image to be used to deal with logging as a sidecar. No
      # validation is carried out as this can be any arbitrary repo and tag. It
      # will default to the latest supported version of Fluent Bit.
      image: couchbase/fluent-bit:1.0.0
      # Resources is the resource requirements for the sidecar container. Will
      # be populated by Kubernetes defaults if not specified.
      resources:
        # Limits describes the maximum amount of compute resources allowed. More
        # info: https://kubernetes.io/docs/concepts/configuration/manage-
        # compute-resources-container/
        limits: null
        # Requests describes the minimum amount of compute resources required.
        # If Requests is omitted for a container, it defaults to Limits if that
        # is explicitly specified, otherwise to an implementation-defined value.
        # More info: https://kubernetes.io/docs/concepts/configuration/manage-
        # compute-resources-container/
        requests: null
# Monitoring defines any Operator managed integration into 3rd party monitoring
# infrastructure.
monitoring:
  # Prometheus provides integration with Prometheus monitoring.
  prometheus:
    # AuthorizationSecret is the name of a Kubernetes secret that contains a
    # bearer token to authorize GET requests to the metrics endpoint
    authorizationSecret: null
    # Enabled is a boolean that enables/disables the metrics sidecar container.
    enabled: null
    # Image is the metrics image to be used to collect metrics. No validation is
    # carried out as this can be any arbitrary repo and tag.
    image: null
    # Resources is the resource requirements for the metrics container. Will be
    # populated by Kubernetes defaults if not specified.
    resources:
      # Limits describes the maximum amount of compute resources allowed. More
      # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
      # resources-container/
      limits: null
      # Requests describes the minimum amount of compute resources required. If
      # Requests is omitted for a container, it defaults to Limits if that is
      # explicitly specified, otherwise to an implementation-defined value. More
      # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
      # resources-container/
      requests: null
# Networking defines Couchbase cluster networking options such as network
# topology, TLS and DDNS settings.
networking:
  # DEVELOPER PREVIEW - this feature is not for production use. AddressFamily
  # allows the manual selection of the address family to use. Couchbase server
  # will default to "IPv4" regardless of underlying network configuration, so
  # this must be manually set to enable use on an "IPv6" only network.  This
  # field is immutable and cannot be changed once set.
  addressFamily: null
  # AdminConsoleServiceTemplate provides a template used by the Operator to
  # create and manage the admin console service.  This allows services to be
  # annotated, the service type defined and any other options that Kubernetes
  # provides.  When using a LoadBalancer service type, TLS and dynamic DNS must
  # also be enabled. The Operator reserves the right to modify or replace any
  # field.  More info:
  # https://kubernetes.io/docs/reference/generated/kubernetes-
  # api/v1.19/#service-v1-core
  adminConsoleServiceTemplate:
    # Standard objects metadata.  This is a curated version for use with
    # Couchbase resource templates.
    metadata:
      # Annotations is an unstructured key value map stored with a resource that
      # may be set by external tools to store and retrieve arbitrary metadata.
      # They are not queryable and should be preserved when modifying objects.
      # More info: http://kubernetes.io/docs/user-guide/annotations
      annotations: null
      # Map of string keys and values that can be used to organize and
      # categorize (scope and select) objects. May match selectors of
      # replication controllers and services. More info:
      # http://kubernetes.io/docs/user-guide/labels
      labels: null
    # ServiceSpec describes the attributes that a user creates on a service.
    spec:
      # clusterIP is the IP address of the service and is usually assigned
      # randomly by the master. If an address is specified manually and is not
      # in use by others, it will be allocated to the service; otherwise,
      # creation of the service will fail. This field can not be changed through
      # updates. Valid values are "None", empty string (""), or a valid IP
      # address. "None" can be specified for headless services when proxying is
      # not required. Only applies to types ClusterIP, NodePort, and
      # LoadBalancer. Ignored if type is ExternalName. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#virtual-ips-and-service-proxies
      clusterIP: null
      # externalIPs is a list of IP addresses for which nodes in the cluster
      # will also accept traffic for this service.  These IPs are not managed by
      # Kubernetes.  The user is responsible for ensuring that traffic arrives
      # at a node with this IP.  A common example is external load-balancers
      # that are not part of the Kubernetes system.
      externalIPs: null
      # externalName is the external reference that kubedns or equivalent will
      # return as a CNAME record for this service. No proxying will be involved.
      # Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
      # and requires Type to be ExternalName.
      externalName: null
      # externalTrafficPolicy denotes if this Service desires to route external
      # traffic to node-local or cluster-wide endpoints. "Local" preserves the
      # client source IP and avoids a second hop for LoadBalancer and Nodeport
      # type services, but risks potentially imbalanced traffic spreading.
      # "Cluster" obscures the client source IP and may cause a second hop to
      # another node, but should have good overall load-spreading.
      externalTrafficPolicy: null
      # healthCheckNodePort specifies the healthcheck nodePort for the service.
      # If not specified, HealthCheckNodePort is created by the service api
      # backend with the allocated nodePort. Will use user-specified nodePort
      # value if specified by the client. Only effects when Type is set to
      # LoadBalancer and ExternalTrafficPolicy is set to Local.
      healthCheckNodePort: null
      # ipFamily specifies whether this Service has a preference for a
      # particular IP family (e.g. IPv4 vs. IPv6) when the IPv6DualStack feature
      # gate is enabled. In a dual-stack cluster, you can specify ipFamily when
      # creating a ClusterIP Service to determine whether the controller will
      # allocate an IPv4 or IPv6 IP for it, and you can specify ipFamily when
      # creating a headless Service to determine whether it will have IPv4 or
      # IPv6 Endpoints. In either case, if you do not specify an ipFamily
      # explicitly, it will default to the cluster's primary IP family. This
      # field is part of an alpha feature, and you should not make any
      # assumptions about its semantics other than those described above. In
      # particular, you should not assume that it can (or cannot) be changed
      # after creation time; that it can only have the values "IPv4" and "IPv6";
      # or that its current value on a given Service correctly reflects the
      # current state of that Service. (For ClusterIP Services, look at
      # clusterIP to see if the Service is IPv4 or IPv6. For headless Services,
      # look at the endpoints, which may be dual-stack in the future. For
      # ExternalName Services, ipFamily has no meaning, but it may be set to an
      # irrelevant value anyway.)
      ipFamily: null
      # Only applies to Service Type: LoadBalancer LoadBalancer will get created
      # with the IP specified in this field. This feature depends on whether the
      # underlying cloud-provider supports specifying the loadBalancerIP when a
      # load balancer is created. This field will be ignored if the cloud-
      # provider does not support the feature.
      loadBalancerIP: null
      # If specified and supported by the platform, this will restrict traffic
      # through the cloud-provider load-balancer will be restricted to the
      # specified client IPs. This field will be ignored if the cloud-provider
      # does not support the feature." More info:
      # https://kubernetes.io/docs/tasks/access-application-cluster/configure-
      # cloud-provider-firewall/
      loadBalancerSourceRanges: null
      # publishNotReadyAddresses indicates that any agent which deals with
      # endpoints for this Service should disregard any indications of
      # ready/not-ready. The primary use case for setting this field is for a
      # StatefulSet's Headless Service to propagate SRV DNS records for its Pods
      # for the purpose of peer discovery. The Kubernetes controllers that
      # generate Endpoints and EndpointSlice resources for Services interpret
      # this to mean that all endpoints are considered "ready" even if the Pods
      # themselves are not. Agents which consume only Kubernetes generated
      # endpoints through the Endpoints or EndpointSlice resources can safely
      # assume this behavior.
      publishNotReadyAddresses: null
      # Route service traffic to pods with label keys and values matching this
      # selector. If empty or not present, the service is assumed to have an
      # external process managing its endpoints, which Kubernetes will not
      # modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
      # Ignored if type is ExternalName. More info:
      # https://kubernetes.io/docs/concepts/services-networking/service/
      selector: null
      # Supports "ClientIP" and "None". Used to maintain session affinity.
      # Enable client IP based session affinity. Must be ClientIP or None.
      # Defaults to None. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#virtual-ips-and-service-proxies
      sessionAffinity: null
      # sessionAffinityConfig contains the configurations of session affinity.
      sessionAffinityConfig:
        # clientIP contains the configurations of Client IP based session
        # affinity.
        clientIP:
          # timeoutSeconds specifies the seconds of ClientIP type session sticky
          # time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity
          # == "ClientIP". Default value is 10800(for 3 hours).
          timeoutSeconds: null
      # topologyKeys is a preference-order list of topology keys which
      # implementations of services should use to preferentially sort endpoints
      # when accessing this Service, it can not be used at the same time as
      # externalTrafficPolicy=Local. Topology keys must be valid label keys and
      # at most 16 keys may be specified. Endpoints are chosen based on the
      # first topology key with available backends. If this field is specified
      # and all entries have no backends that match the topology of the client,
      # the service has no backends for that client and connections should fail.
      # The special value "*" may be used to mean "any topology". This catch-all
      # value, if used, only makes sense as the last value in the list. If this
      # is not specified or empty, no topology constraints will be applied.
      topologyKeys: null
      # type determines how the Service is exposed. Defaults to ClusterIP. Valid
      # options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
      # "ExternalName" maps to the specified externalName. "ClusterIP" allocates
      # a cluster-internal IP address for load-balancing to endpoints. Endpoints
      # are determined by the selector or if that is not specified, by manual
      # construction of an Endpoints object. If clusterIP is "None", no virtual
      # IP is allocated and the endpoints are published as a set of endpoints
      # rather than a stable IP. "NodePort" builds on ClusterIP and allocates a
      # port on every node which routes to the clusterIP. "LoadBalancer" builds
      # on NodePort and creates an external load-balancer (if supported in the
      # current cloud) which routes to the clusterIP. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#publishing-services-service-types
      type: null
  # DEPRECATED - by adminConsoleServiceTemplate. AdminConsoleServiceType defines
  # whether to create a node port or load balancer service. When using a
  # LoadBalancer service type, TLS and dynamic DNS must also be enabled. This
  # field must be one of "NodePort" or "LoadBalancer", defaulting to "NodePort".
  adminConsoleServiceType: NodePort
  # DEPRECATED - not required by Couchbase Server 6.5.0 onward.
  # AdminConsoleServices is a selector to choose specific services to expose via
  # the admin console. This field may contain any of "data", "index", "query",
  # "search", "eventing" and "analytics".  Each service may only be included
  # once.
  adminConsoleServices: null
  # DisableUIOverHTTP is used to explicitly enable and disable UI access over
  # the HTTP protocol.  If not specified, this field defaults to false.
  disableUIOverHTTP: null
  # DisableUIOverHTTPS is used to explicitly enable and disable UI access over
  # the HTTPS protocol.  If not specified, this field defaults to false.
  disableUIOverHTTPS: null
  # DNS defines information required for Dynamic DNS support.
  dns:
    # Domain is the domain to create pods in.  When populated the Operator will
    # annotate the admin console and per-pod services with the key "external-
    # dns.alpha.kubernetes.io/hostname".  These annotations can be used directly
    # by a Kubernetes External-DNS controller to replicate load balancer service
    # IP addresses into a public DNS server.
    domain: null
  # ExposeAdminConsole creates a service referencing the admin console. The
  # service is configured by the adminConsoleServiceTemplate field.
  exposeAdminConsole: null
  # ExposedFeatureServiceTemplate provides a template used by the Operator to
  # create and manage per-pod services.  This allows services to be annotated,
  # the service type defined and any other options that Kubernetes provides.
  # When using a LoadBalancer service type, TLS and dynamic DNS must also be
  # enabled. The Operator reserves the right to modify or replace any field.
  # More info: https://kubernetes.io/docs/reference/generated/kubernetes-
  # api/v1.19/#service-v1-core
  exposedFeatureServiceTemplate:
    # Standard objects metadata.  This is a curated version for use with
    # Couchbase resource templates.
    metadata:
      # Annotations is an unstructured key value map stored with a resource that
      # may be set by external tools to store and retrieve arbitrary metadata.
      # They are not queryable and should be preserved when modifying objects.
      # More info: http://kubernetes.io/docs/user-guide/annotations
      annotations: null
      # Map of string keys and values that can be used to organize and
      # categorize (scope and select) objects. May match selectors of
      # replication controllers and services. More info:
      # http://kubernetes.io/docs/user-guide/labels
      labels: null
    # ServiceSpec describes the attributes that a user creates on a service.
    spec:
      # clusterIP is the IP address of the service and is usually assigned
      # randomly by the master. If an address is specified manually and is not
      # in use by others, it will be allocated to the service; otherwise,
      # creation of the service will fail. This field can not be changed through
      # updates. Valid values are "None", empty string (""), or a valid IP
      # address. "None" can be specified for headless services when proxying is
      # not required. Only applies to types ClusterIP, NodePort, and
      # LoadBalancer. Ignored if type is ExternalName. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#virtual-ips-and-service-proxies
      clusterIP: null
      # externalIPs is a list of IP addresses for which nodes in the cluster
      # will also accept traffic for this service.  These IPs are not managed by
      # Kubernetes.  The user is responsible for ensuring that traffic arrives
      # at a node with this IP.  A common example is external load-balancers
      # that are not part of the Kubernetes system.
      externalIPs: null
      # externalName is the external reference that kubedns or equivalent will
      # return as a CNAME record for this service. No proxying will be involved.
      # Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
      # and requires Type to be ExternalName.
      externalName: null
      # externalTrafficPolicy denotes if this Service desires to route external
      # traffic to node-local or cluster-wide endpoints. "Local" preserves the
      # client source IP and avoids a second hop for LoadBalancer and Nodeport
      # type services, but risks potentially imbalanced traffic spreading.
      # "Cluster" obscures the client source IP and may cause a second hop to
      # another node, but should have good overall load-spreading.
      externalTrafficPolicy: null
      # healthCheckNodePort specifies the healthcheck nodePort for the service.
      # If not specified, HealthCheckNodePort is created by the service api
      # backend with the allocated nodePort. Will use user-specified nodePort
      # value if specified by the client. Only effects when Type is set to
      # LoadBalancer and ExternalTrafficPolicy is set to Local.
      healthCheckNodePort: null
      # ipFamily specifies whether this Service has a preference for a
      # particular IP family (e.g. IPv4 vs. IPv6) when the IPv6DualStack feature
      # gate is enabled. In a dual-stack cluster, you can specify ipFamily when
      # creating a ClusterIP Service to determine whether the controller will
      # allocate an IPv4 or IPv6 IP for it, and you can specify ipFamily when
      # creating a headless Service to determine whether it will have IPv4 or
      # IPv6 Endpoints. In either case, if you do not specify an ipFamily
      # explicitly, it will default to the cluster's primary IP family. This
      # field is part of an alpha feature, and you should not make any
      # assumptions about its semantics other than those described above. In
      # particular, you should not assume that it can (or cannot) be changed
      # after creation time; that it can only have the values "IPv4" and "IPv6";
      # or that its current value on a given Service correctly reflects the
      # current state of that Service. (For ClusterIP Services, look at
      # clusterIP to see if the Service is IPv4 or IPv6. For headless Services,
      # look at the endpoints, which may be dual-stack in the future. For
      # ExternalName Services, ipFamily has no meaning, but it may be set to an
      # irrelevant value anyway.)
      ipFamily: null
      # Only applies to Service Type: LoadBalancer LoadBalancer will get created
      # with the IP specified in this field. This feature depends on whether the
      # underlying cloud-provider supports specifying the loadBalancerIP when a
      # load balancer is created. This field will be ignored if the cloud-
      # provider does not support the feature.
      loadBalancerIP: null
      # If specified and supported by the platform, this will restrict traffic
      # through the cloud-provider load-balancer will be restricted to the
      # specified client IPs. This field will be ignored if the cloud-provider
      # does not support the feature." More info:
      # https://kubernetes.io/docs/tasks/access-application-cluster/configure-
      # cloud-provider-firewall/
      loadBalancerSourceRanges: null
      # publishNotReadyAddresses indicates that any agent which deals with
      # endpoints for this Service should disregard any indications of
      # ready/not-ready. The primary use case for setting this field is for a
      # StatefulSet's Headless Service to propagate SRV DNS records for its Pods
      # for the purpose of peer discovery. The Kubernetes controllers that
      # generate Endpoints and EndpointSlice resources for Services interpret
      # this to mean that all endpoints are considered "ready" even if the Pods
      # themselves are not. Agents which consume only Kubernetes generated
      # endpoints through the Endpoints or EndpointSlice resources can safely
      # assume this behavior.
      publishNotReadyAddresses: null
      # Route service traffic to pods with label keys and values matching this
      # selector. If empty or not present, the service is assumed to have an
      # external process managing its endpoints, which Kubernetes will not
      # modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
      # Ignored if type is ExternalName. More info:
      # https://kubernetes.io/docs/concepts/services-networking/service/
      selector: null
      # Supports "ClientIP" and "None". Used to maintain session affinity.
      # Enable client IP based session affinity. Must be ClientIP or None.
      # Defaults to None. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#virtual-ips-and-service-proxies
      sessionAffinity: null
      # sessionAffinityConfig contains the configurations of session affinity.
      sessionAffinityConfig:
        # clientIP contains the configurations of Client IP based session
        # affinity.
        clientIP:
          # timeoutSeconds specifies the seconds of ClientIP type session sticky
          # time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity
          # == "ClientIP". Default value is 10800(for 3 hours).
          timeoutSeconds: null
      # topologyKeys is a preference-order list of topology keys which
      # implementations of services should use to preferentially sort endpoints
      # when accessing this Service, it can not be used at the same time as
      # externalTrafficPolicy=Local. Topology keys must be valid label keys and
      # at most 16 keys may be specified. Endpoints are chosen based on the
      # first topology key with available backends. If this field is specified
      # and all entries have no backends that match the topology of the client,
      # the service has no backends for that client and connections should fail.
      # The special value "*" may be used to mean "any topology". This catch-all
      # value, if used, only makes sense as the last value in the list. If this
      # is not specified or empty, no topology constraints will be applied.
      topologyKeys: null
      # type determines how the Service is exposed. Defaults to ClusterIP. Valid
      # options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
      # "ExternalName" maps to the specified externalName. "ClusterIP" allocates
      # a cluster-internal IP address for load-balancing to endpoints. Endpoints
      # are determined by the selector or if that is not specified, by manual
      # construction of an Endpoints object. If clusterIP is "None", no virtual
      # IP is allocated and the endpoints are published as a set of endpoints
      # rather than a stable IP. "NodePort" builds on ClusterIP and allocates a
      # port on every node which routes to the clusterIP. "LoadBalancer" builds
      # on NodePort and creates an external load-balancer (if supported in the
      # current cloud) which routes to the clusterIP. More info:
      # https://kubernetes.io/docs/concepts/services-
      # networking/service/#publishing-services-service-types
      type: null
  # DEPRECATED - by exposedFeatureServiceTemplate. ExposedFeatureServiceType
  # defines whether to create a node port or load balancer service. When using a
  # LoadBalancer service type, TLS and dynamic DNS must also be enabled. This
  # field must be one of "NodePort" or "LoadBalancer", defaulting to "NodePort".
  exposedFeatureServiceType: NodePort
  # DEPRECATED  - by exposedFeatureServiceTemplate. ExposedFeatureTrafficPolicy
  # defines how packets should be routed from a load balancer service to a
  # Couchbase pod.  When local, traffic is routed directly to the pod.  When
  # cluster, traffic is routed to any node, then forwarded on.  While cluster
  # routing may be slower, there are some situations where it is required for
  # connectivity.  This field must be either "Cluster" or "Local", defaulting to
  # "Local",
  exposedFeatureTrafficPolicy: null
  # ExposedFeatures is a list of Couchbase features to expose when using a
  # networking model that exposes the Couchbase cluster externally to
  # Kubernetes.  This field also triggers the creation of per-pod services used
  # by clients to connect to the Couchbase cluster.  When admin, only the
  # administrator port is exposed, allowing remote administration.  When xdcr,
  # only the services required for remote replication are exposed. The xdcr
  # feature is only required when the cluster is the destrination of an XDCR
  # replication.  When client, all services are exposed as required for client
  # SDK operation. This field may contain any of "admin", "xdcr" and "client".
  # Each feature may only be included once.
  exposedFeatures: null
  # DEPRECATED - by adminConsoleServiceTemplate and
  # exposedFeatureServiceTemplate. LoadBalancerSourceRanges applies only when an
  # exposed service is of type LoadBalancer and limits the source IP ranges that
  # are allowed to use the service.  Items must use IPv4 class-less interdomain
  # routing (CIDR) notation e.g. 10.0.0.0/16.
  loadBalancerSourceRanges: null
  # NetworkPlatform is used to enable support for various networking
  # technologies.  This field must be one of "Istio".
  networkPlatform: null
  # DEPRECATED - by adminConsoleServiceTemplate and
  # exposedFeatureServiceTemplate. ServiceAnnotations allows services to be
  # annotated with custom labels. Operator annotations are merged on top of
  # these so have precedence as they are required for correct operation.
  serviceAnnotations: null
  # TLS defines the TLS configuration for the cluster including server and
  # client certificate configuration, and TLS security policies.
  tls:
    # CipherSuites specifies a list of cipher suites for Couchbase server to
    # select from when negotiating TLS handshakes with a client.  Suites are not
    # validated by the Operator.  Run "openssl ciphers -v" in a Couchbase server
    # pod to interrogate supported values.
    cipherSuites: null
    # ClientCertificatePaths defines where to look in client certificates in
    # order to extract the user name.
    clientCertificatePaths:
      # Delimiter if specified allows a suffix to be stripped from the username,
      # once extracted from the certificate path.
      delimiter: null
      # Path defines where in the X.509 specification to extract the username
      # from. This field must be either "subject.cn", "san.uri", "san.dnsname"
      # or  "san.email".
      path: null
      # Prefix allows a prefix to be stripped from the username, once extracted
      # from the certificate path.
      prefix: null
    # ClientCertificatePolicy defines the client authentication policy to use.
    # If set, the Operator expects TLS configuration to contain a valid
    # certificate/key pair for the Administrator account.
    clientCertificatePolicy: null
    # NodeToNodeEncryption specifies whether to encrypt data between Couchbase
    # nodes within the same cluster.  This may come at the expense of
    # performance.  When control plane only encryption is used, only cluster
    # management traffic is encrypted between nodes.  When all, all traffic is
    # encrypted, including database documents. This field must be either
    # "ControlPlaneOnly" or "All".
    nodeToNodeEncryption: null
    # SecretSource enables the user to specify a secret conforming to the
    # Kubernetes TLS secret specification.
    secretSource:
      # ClientSecretName specifies the secret name, in the same namespace as the
      # cluster, the contains client TLS data.  The secret is expected to
      # contain "tls.crt" and "tls.key" as per the Kubernetes.io/tls secret
      # type.
      clientSecretName: null
      # ServerSecretName specfies the secret name, in the same namespace as the
      # cluster, that contains server TLS data.  The secret is expected to
      # contain "tls.crt" and "tls.key" as per the kubernetes.io/tls secret
      # type.  It also additionally must contain "ca.crt".
      serverSecretName: null
    # Static enables user to generate static x509 certificates and keys, put
    # them into Kubernetes secrets, and specify them here.  Static secrets are
    # very Couchbase specific.
    static:
      # OperatorSecret is a secret name containing TLS certs used by operator to
      # talk securely to this cluster.  The secret must contain a CA certificate
      # (data key ca.crt).  If client authentication is enabled, then the secret
      # must also contain a client certificate chain (data key "couchbase-
      # operator.crt") and private key (data key "couchbase-operator.key").
      operatorSecret: null
      # ServerSecret is a secret name containing TLS certs used by each
      # Couchbase member pod for the communication between Couchbase server and
      # its clients.  The secret must contain a certificate chain (data key
      # "couchbase-operator.crt") and a private key (data key "couchbase-
      # operator.key").  The private key must be in the PKCS#1 RSA format.  The
      # certificate chain must have a required set of X.509v3 subject
      # alternative names for all cluster addressing modes.  See the Operator
      # TLS documentation for more information.
      serverSecret: null
    # TLSMinimumVersion specifies the minimum TLS version the Couchbase server
    # can negotiate with a client.  Must be one of TLS1.0, TLS1.1 or TLS1.2,
    # defaulting to TLS1.2.
    tlsMinimumVersion: TLS1.2
# Paused is to pause the control of the operator for the Couchbase cluster. This
# does not pause the cluster itself, instead stopping the operator from taking
# any action.
paused: null
# Platform gives a hint as to what platform we are running on and how to
# configure services.  This field must be one of "aws", "gke" or "azure".
platform: null
# RecoveryPolicy controls how aggressive the Operator is when recovering cluster
# topology.  When PrioritizeDataIntegrity, the Operator will delegate failover
# exclusively to Couchbase server, relying on it to only allow recovery when
# safe to do so.  When PrioritizeUptime, the Operator will wait for a period
# after the expected auto-failover of the cluster, before forcefully failing-
# over the pods. This may cause data loss, and is only expected to be used on
# clusters with ephemeral data, where the loss of the pod means that the data is
# known to be unrecoverable. This field must be either "PrioritizeDataIntegrity"
# or "PrioritizeUptime", defaulting to "PrioritizeDataIntegrity".
recoveryPolicy: null
# When `spec.upgradeStrategy` is set to `RollingUpgrade` it will, by default,
# upgrade one pod at a time.  If this field is specified then that number can be
# increased.
rollingUpgrade:
  # MaxUpgradable allows the number of pods affected by an upgrade at any one
  # time to be increased.  By default a rolling upgrade will upgrade one pod at
  # a time.  This field allows that limit to be removed. This field must be
  # greater than zero. The smallest of `maxUpgradable` and
  # `maxUpgradablePercent` takes precedence if both are defined.
  maxUpgradable: null
  # MaxUpgradablePercent allows the number of pods affected by an upgrade at any
  # one time to be increased.  By default a rolling upgrade will upgrade one pod
  # at a time.  This field allows that limit to be removed. This field must be
  # an integer percentage, e.g. "10%", in the range 1% to 100%. Percentages are
  # relative to the total cluster size, and rounded down to the nearest whole
  # number, with a minimum of 1.  For example, a 10 pod cluster, and 25% allowed
  # to upgrade, would yield 2.5 pods per iteration, rounded down to 2. The
  # smallest of `maxUpgradable` and `maxUpgradablePercent` takes precedence if
  # both are defined.
  maxUpgradablePercent: null
# Security defines Couchbase cluster security options such as the administrator
# account username and password, and user RBAC settings.
security:
  # AdminSecret is the name of a Kubernetes secret to use for administrator
  # authentication. The admin secret must contain the keys "username" and
  # "password".  The password data must be at least 6 characters in length, and
  # not contain the any of the characters `()<>,;:\"/[]?={}`.
  adminSecret: null
  # LDAP Settings
  ldap:
    # Enables using LDAP to authenticate users.
    authenticationEnabled: true
    # Enables use of LDAP groups for authorization.
    authorizationEnabled: null
    # DN to use for searching users and groups synchronization.
    bindDN: null
    # BindSecret is the name of a Kubernetes secret to use containing password
    # for LDAP user binding
    bindSecret: null
    # Certificate in PEM format to be used in LDAP server certificate validation
    cacert: null
    # Lifetime of values in cache in milliseconds. Default 300000 ms.
    cacheValueLifetime: null
    # Encryption method to communicate with LDAP servers. Can be
    # StartTLSExtension, TLS, or false.
    encryption: null
    # LDAP query, to get the users' groups by username in RFC4516 format.
    groupsQuery: null
    # List of LDAP hosts.
    hosts: null
    # If enabled Couchbase server will try to recursively search for groups for
    # every discovered ldap group. groups_query will be user for the search.
    nestedGroupsEnabled: null
    # Maximum number of recursive groups requests the server is allowed to
    # perform. Requires NestedGroupsEnabled.  Values between 1 and 100: the
    # default is 10.
    nestedGroupsMaxDepth: null
    # LDAP port
    port: null
    # Whether server certificate validation be enabled
    serverCertValidation: null
    # TLSSecret is the name of a Kubernetes secret to use for LDAP ca cert.
    tlsSecret: null
    # User to distinguished name (DN) mapping. If none is specified, the
    # username is used as the users distinguished name.
    userDNMapping:
      # Query is the LDAP query to run to map from Couchbase user to LDAP
      # distinguished name.
      query: null
      # This field specifies list of templates to use for providing username to
      # DN mapping. The template may contain a placeholder specified as `%u` to
      # represent the Couchbase user who is attempting to gain access.
      template: null
  # Couchbase RBAC Users
  rbac:
    # Managed defines whether RBAC is managed by us or the clients.
    managed: null
    # Selector is a label selector used to list RBAC resources in the namespace
    # that are managed by the Operator.
    selector:
      # matchExpressions is a list of label selector requirements. The
      # requirements are ANDed.
      matchExpressions:
        # key is the label key that the selector applies to.
        key: null
        # operator represents a key's relationship to a set of values. Valid
        # operators are In, NotIn, Exists and DoesNotExist.
        operator: null
        # values is an array of string values. If the operator is In or NotIn,
        # the values array must be non-empty. If the operator is Exists or
        # DoesNotExist, the values array must be empty. This array is replaced
        # during a strategic merge patch.
        values: null
      # matchLabels is a map of {key,value} pairs. A single {key,value} in the
      # matchLabels map is equivalent to an element of matchExpressions, whose
      # key field is "key", the operator is "In", and the values array contains
      # only "value". The requirements are ANDed.
      matchLabels: null
# SecurityContext allows the configuration of the security context for all
# Couchbase server pods.  When using persistent volumes you may need to set the
# fsGroup field in order to write to the volume.  For non-root clusters you must
# also set runAsUser to 1000, corresponding to the Couchbase user in official
# container images.  More info: https://kubernetes.io/docs/tasks/configure-pod-
# container/security-context/
securityContext:
  # A special supplemental group that applies to all containers in a pod. Some
  # volume types allow the Kubelet to change the ownership of that volume to be
  # owned by the pod:   1. The owning GID will be the FSGroup 2. The setgid bit
  # is set (new files created in the volume will be owned by FSGroup) 3. The
  # permission bits are OR'd with rw-rw----   If unset, the Kubelet will not
  # modify the ownership and permissions of any volume.
  fsGroup: null
  # fsGroupChangePolicy defines behavior of changing ownership and permission of
  # the volume before being exposed inside Pod. This field will only apply to
  # volume types which support fsGroup based ownership(and permissions). It will
  # have no effect on ephemeral volume types such as: secret, configmaps and
  # emptydir. Valid values are "OnRootMismatch" and "Always". If not specified
  # defaults to "Always".
  fsGroupChangePolicy: null
  # The GID to run the entrypoint of the container process. Uses runtime default
  # if unset. May also be set in SecurityContext.  If set in both
  # SecurityContext and PodSecurityContext, the value specified in
  # SecurityContext takes precedence for that container.
  runAsGroup: null
  # Indicates that the container must run as a non-root user. If true, the
  # Kubelet will validate the image at runtime to ensure that it does not run as
  # UID 0 (root) and fail to start the container if it does. If unset or false,
  # no such validation will be performed. May also be set in SecurityContext.
  # If set in both SecurityContext and PodSecurityContext, the value specified
  # in SecurityContext takes precedence.
  runAsNonRoot: null
  # The UID to run the entrypoint of the container process. Defaults to user
  # specified in image metadata if unspecified. May also be set in
  # SecurityContext.  If set in both SecurityContext and PodSecurityContext, the
  # value specified in SecurityContext takes precedence for that container.
  runAsUser: null
  # The SELinux context to be applied to all containers. If unspecified, the
  # container runtime will allocate a random SELinux context for each container.
  # May also be set in SecurityContext.  If set in both SecurityContext and
  # PodSecurityContext, the value specified in SecurityContext takes precedence
  # for that container.
  seLinuxOptions:
    # Level is SELinux level label that applies to the container.
    level: null
    # Role is a SELinux role label that applies to the container.
    role: null
    # Type is a SELinux type label that applies to the container.
    type: null
    # User is a SELinux user label that applies to the container.
    user: null
  # The seccomp options to use by the containers in this pod.
  seccompProfile:
    # localhostProfile indicates a profile defined in a file on the node should
    # be used. The profile must be preconfigured on the node to work. Must be a
    # descending path, relative to the kubelet's configured seccomp profile
    # location. Must only be set if type is "Localhost".
    localhostProfile: null
    # type indicates which kind of seccomp profile will be applied. Valid
    # options are:   Localhost - a profile defined in a file on the node should
    # be used. RuntimeDefault - the container runtime default profile should be
    # used. Unconfined - no profile should be applied.
    type: null
  # A list of groups applied to the first process run in each container, in
  # addition to the container's primary GID.  If unspecified, no groups will be
  # added to any container.
  supplementalGroups: null
  # Sysctls hold a list of namespaced sysctls used for the pod. Pods with
  # unsupported sysctls (by the container runtime) might fail to launch.
  sysctls:
    # Name of a property to set
    name: null
    # Value of a property to set
    value: null
  # The Windows specific settings applied to all containers. If unspecified, the
  # options within a container's SecurityContext will be used. If set in both
  # SecurityContext and PodSecurityContext, the value specified in
  # SecurityContext takes precedence.
  windowsOptions:
    # GMSACredentialSpec is where the GMSA admission webhook
    # (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of
    # the GMSA credential spec named by the GMSACredentialSpecName field.
    gmsaCredentialSpec: null
    # GMSACredentialSpecName is the name of the GMSA credential spec to use.
    gmsaCredentialSpecName: null
    # The UserName in Windows to run the entrypoint of the container process.
    # Defaults to the user specified in image metadata if unspecified. May also
    # be set in PodSecurityContext. If set in both SecurityContext and
    # PodSecurityContext, the value specified in SecurityContext takes
    # precedence.
    runAsUserName: null
# ServerGroups define the set of availability zones you want to distribute pods
# over, and construct Couchbase server groups for.  By default, most cloud
# providers will label nodes with the key "failure-
# domain.beta.kubernetes.io/zone", the values associated with that key are used
# here to provide explicit scheduling by the Operator.  You may manually label
# nodes using the "failure-domain.beta.kubernetes.io/zone" key, to provide
# failure-domain aware scheduling when none is provided for you.  Global server
# groups are applied to all server classes, and may be overridden on a per-
# server class basis to give more control over scheduling and server groups.
serverGroups: null
# Servers defines server classes for the Operator to provision and manage. A
# server class defines what services are running and how many members make up
# that class.  Specifying multiple server classes allows the Operator to
# provision clusters with Multi-Dimensional Scaling (MDS).  At least one server
# class must be defined, and at least one server class must be running the data
# service.
servers:
  # AutoscaledEnabled defines whether the autoscaling feature is enabled for
  # this class. When true, the Operator will create a CouchbaseAutoscaler
  # resource for this server class.  The CouchbaseAutoscaler implements the
  # Kubernetes scale API and can be controlled by the Kubernetes horizontal pod
  # autoscaler (HPA).
  autoscaleEnabled: null
  # Env allows the setting of environment variables in the Couchbase server
  # container.
  env:
    # Name of the environment variable. Must be a C_IDENTIFIER.
    name: null
    # Variable references $(VAR_NAME) are expanded using the previous defined
    # environment variables in the container and any service environment
    # variables. If a variable cannot be resolved, the reference in the input
    # string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
    # double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
    # regardless of whether the variable exists or not. Defaults to "".
    value: null
    # Source for the environment variable's value. Cannot be used if value is
    # not empty.
    valueFrom:
      # Selects a key of a ConfigMap.
      configMapKeyRef:
        # The key to select.
        key: null
        # Name of the referent. More info:
        # https://kubernetes.io/docs/concepts/overview/working-with-
        # objects/names/#names TODO: Add other useful fields. apiVersion, kind,
        # uid?
        name: null
        # Specify whether the ConfigMap or its key must be defined
        optional: null
      # Selects a field of the pod: supports metadata.name, metadata.namespace,
      # `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
      # spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP,
      # status.podIPs.
      fieldRef:
        # Version of the schema the FieldPath is written in terms of, defaults
        # to "v1".
        apiVersion: null
        # Path of the field to select in the specified API version.
        fieldPath: null
      # Selects a resource of the container: only resources limits and requests
      # (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu,
      # requests.memory and requests.ephemeral-storage) are currently supported.
      resourceFieldRef:
        # Container name: required for volumes, optional for env vars
        containerName: null
        # Specifies the output format of the exposed resources, defaults to "1"
        divisor: null
        # Required: resource to select
        resource: null
      # Selects a key of a secret in the pod's namespace
      secretKeyRef:
        # The key of the secret to select from.  Must be a valid secret key.
        key: null
        # Name of the referent. More info:
        # https://kubernetes.io/docs/concepts/overview/working-with-
        # objects/names/#names TODO: Add other useful fields. apiVersion, kind,
        # uid?
        name: null
        # Specify whether the Secret or its key must be defined
        optional: null
  # EnvFrom allows the setting of environment variables in the Couchbase server
  # container.
  envFrom:
    # The ConfigMap to select from
    configMapRef:
      # Name of the referent. More info:
      # https://kubernetes.io/docs/concepts/overview/working-with-
      # objects/names/#names TODO: Add other useful fields. apiVersion, kind,
      # uid?
      name: null
      # Specify whether the ConfigMap must be defined
      optional: null
    # An optional identifier to prepend to each key in the ConfigMap. Must be a
    # C_IDENTIFIER.
    prefix: null
    # The Secret to select from
    secretRef:
      # Name of the referent. More info:
      # https://kubernetes.io/docs/concepts/overview/working-with-
      # objects/names/#names TODO: Add other useful fields. apiVersion, kind,
      # uid?
      name: null
      # Specify whether the Secret must be defined
      optional: null
  # Name is a textual name for the server configuration and must be unique. The
  # name is used by the operator to uniquely identify a server class, and map
  # pods back to an intended configuration.
  name: null
  # Pod defines a template used to create pod for each Couchbase server
  # instance.  Modifying pod metadata such as labels and annotations will update
  # the pod in-place.  Any other modification will result in a cluster upgrade
  # in order to fulfill the request. The Operator reserves the right to modify
  # or replace any field.  More info:
  # https://kubernetes.io/docs/reference/generated/kubernetes-
  # api/v1.19/#pod-v1-core
  pod:
    # Standard objects metadata.  This is a curated version for use with
    # Couchbase resource templates.
    metadata:
      # Annotations is an unstructured key value map stored with a resource that
      # may be set by external tools to store and retrieve arbitrary metadata.
      # They are not queryable and should be preserved when modifying objects.
      # More info: http://kubernetes.io/docs/user-guide/annotations
      annotations: null
      # Map of string keys and values that can be used to organize and
      # categorize (scope and select) objects. May match selectors of
      # replication controllers and services. More info:
      # http://kubernetes.io/docs/user-guide/labels
      labels: null
    # PodSpec is a description of a pod.
    spec:
      # Optional duration in seconds the pod may be active on the node relative
      # to StartTime before the system will actively try to mark it failed and
      # kill associated containers. Value must be a positive integer.
      activeDeadlineSeconds: null
      # If specified, the pod's scheduling constraints
      affinity:
        # Describes node affinity scheduling rules for the pod.
        nodeAffinity:
          # The scheduler will prefer to schedule pods to nodes that satisfy the
          # affinity expressions specified by this field, but it may choose a
          # node that violates one or more of the expressions. The node that is
          # most preferred is the one with the greatest sum of weights, i.e. for
          # each node that meets all of the scheduling requirements (resource
          # request, requiredDuringScheduling affinity expressions, etc.),
          # compute a sum by iterating through the elements of this field and
          # adding "weight" to the sum if the node matches the corresponding
          # matchExpressions; the node(s) with the highest sum are the most
          # preferred.
          preferredDuringSchedulingIgnoredDuringExecution:
            # A node selector term, associated with the corresponding weight.
            preference:
              # A list of node selector requirements by node's labels.
              matchExpressions:
                # The label key that the selector applies to.
                key: null
                # Represents a key's relationship to a set of values. Valid
                # operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                operator: null
                # An array of string values. If the operator is In or NotIn, the
                # values array must be non-empty. If the operator is Exists or
                # DoesNotExist, the values array must be empty. If the operator
                # is Gt or Lt, the values array must have a single element,
                # which will be interpreted as an integer. This array is
                # replaced during a strategic merge patch.
                values: null
              # A list of node selector requirements by node's fields.
              matchFields:
                # The label key that the selector applies to.
                key: null
                # Represents a key's relationship to a set of values. Valid
                # operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                operator: null
                # An array of string values. If the operator is In or NotIn, the
                # values array must be non-empty. If the operator is Exists or
                # DoesNotExist, the values array must be empty. If the operator
                # is Gt or Lt, the values array must have a single element,
                # which will be interpreted as an integer. This array is
                # replaced during a strategic merge patch.
                values: null
            # Weight associated with matching the corresponding
            # nodeSelectorTerm, in the range 1-100.
            weight: null
          # If the affinity requirements specified by this field are not met at
          # scheduling time, the pod will not be scheduled onto the node. If the
          # affinity requirements specified by this field cease to be met at
          # some point during pod execution (e.g. due to an update), the system
          # may or may not try to eventually evict the pod from its node.
          requiredDuringSchedulingIgnoredDuringExecution:
            # Required. A list of node selector terms. The terms are ORed.
            nodeSelectorTerms:
              # A list of node selector requirements by node's labels.
              matchExpressions:
                # The label key that the selector applies to.
                key: null
                # Represents a key's relationship to a set of values. Valid
                # operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                operator: null
                # An array of string values. If the operator is In or NotIn, the
                # values array must be non-empty. If the operator is Exists or
                # DoesNotExist, the values array must be empty. If the operator
                # is Gt or Lt, the values array must have a single element,
                # which will be interpreted as an integer. This array is
                # replaced during a strategic merge patch.
                values: null
              # A list of node selector requirements by node's fields.
              matchFields:
                # The label key that the selector applies to.
                key: null
                # Represents a key's relationship to a set of values. Valid
                # operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
                operator: null
                # An array of string values. If the operator is In or NotIn, the
                # values array must be non-empty. If the operator is Exists or
                # DoesNotExist, the values array must be empty. If the operator
                # is Gt or Lt, the values array must have a single element,
                # which will be interpreted as an integer. This array is
                # replaced during a strategic merge patch.
                values: null
        # Describes pod affinity scheduling rules (e.g. co-locate this pod in
        # the same node, zone, etc. as some other pod(s)).
        podAffinity:
          # The scheduler will prefer to schedule pods to nodes that satisfy the
          # affinity expressions specified by this field, but it may choose a
          # node that violates one or more of the expressions. The node that is
          # most preferred is the one with the greatest sum of weights, i.e. for
          # each node that meets all of the scheduling requirements (resource
          # request, requiredDuringScheduling affinity expressions, etc.),
          # compute a sum by iterating through the elements of this field and
          # adding "weight" to the sum if the node has pods which matches the
          # corresponding podAffinityTerm; the node(s) with the highest sum are
          # the most preferred.
          preferredDuringSchedulingIgnoredDuringExecution:
            # Required. A pod affinity term, associated with the corresponding
            # weight.
            podAffinityTerm:
              # A label query over a set of resources, in this case pods.
              labelSelector:
                # matchExpressions is a list of label selector requirements. The
                # requirements are ANDed.
                matchExpressions:
                  # key is the label key that the selector applies to.
                  key: null
                  # operator represents a key's relationship to a set of values.
                  # Valid operators are In, NotIn, Exists and DoesNotExist.
                  operator: null
                  # values is an array of string values. If the operator is In
                  # or NotIn, the values array must be non-empty. If the
                  # operator is Exists or DoesNotExist, the values array must be
                  # empty. This array is replaced during a strategic merge
                  # patch.
                  values: null
                # matchLabels is a map of {key,value} pairs. A single
                # {key,value} in the matchLabels map is equivalent to an element
                # of matchExpressions, whose key field is "key", the operator is
                # "In", and the values array contains only "value". The
                # requirements are ANDed.
                matchLabels: null
              # namespaces specifies which namespaces the labelSelector applies
              # to (matches against); null or empty list means "this pod's
              # namespace"
              namespaces: null
              # This pod should be co-located (affinity) or not co-located
              # (anti-affinity) with the pods matching the labelSelector in the
              # specified namespaces, where co-located is defined as running on
              # a node whose value of the label with key topologyKey matches
              # that of any node on which any of the selected pods is running.
              # Empty topologyKey is not allowed.
              topologyKey: null
            # weight associated with matching the corresponding podAffinityTerm,
            # in the range 1-100.
            weight: null
          # If the affinity requirements specified by this field are not met at
          # scheduling time, the pod will not be scheduled onto the node. If the
          # affinity requirements specified by this field cease to be met at
          # some point during pod execution (e.g. due to a pod label update),
          # the system may or may not try to eventually evict the pod from its
          # node. When there are multiple elements, the lists of nodes
          # corresponding to each podAffinityTerm are intersected, i.e. all
          # terms must be satisfied.
          requiredDuringSchedulingIgnoredDuringExecution:
            # A label query over a set of resources, in this case pods.
            labelSelector:
              # matchExpressions is a list of label selector requirements. The
              # requirements are ANDed.
              matchExpressions:
                # key is the label key that the selector applies to.
                key: null
                # operator represents a key's relationship to a set of values.
                # Valid operators are In, NotIn, Exists and DoesNotExist.
                operator: null
                # values is an array of string values. If the operator is In or
                # NotIn, the values array must be non-empty. If the operator is
                # Exists or DoesNotExist, the values array must be empty. This
                # array is replaced during a strategic merge patch.
                values: null
              # matchLabels is a map of {key,value} pairs. A single {key,value}
              # in the matchLabels map is equivalent to an element of
              # matchExpressions, whose key field is "key", the operator is
              # "In", and the values array contains only "value". The
              # requirements are ANDed.
              matchLabels: null
            # namespaces specifies which namespaces the labelSelector applies to
            # (matches against); null or empty list means "this pod's namespace"
            namespaces: null
            # This pod should be co-located (affinity) or not co-located (anti-
            # affinity) with the pods matching the labelSelector in the
            # specified namespaces, where co-located is defined as running on a
            # node whose value of the label with key topologyKey matches that of
            # any node on which any of the selected pods is running. Empty
            # topologyKey is not allowed.
            topologyKey: null
        # Describes pod anti-affinity scheduling rules (e.g. avoid putting this
        # pod in the same node, zone, etc. as some other pod(s)).
        podAntiAffinity:
          # The scheduler will prefer to schedule pods to nodes that satisfy the
          # anti-affinity expressions specified by this field, but it may choose
          # a node that violates one or more of the expressions. The node that
          # is most preferred is the one with the greatest sum of weights, i.e.
          # for each node that meets all of the scheduling requirements
          # (resource request, requiredDuringScheduling anti-affinity
          # expressions, etc.), compute a sum by iterating through the elements
          # of this field and adding "weight" to the sum if the node has pods
          # which matches the corresponding podAffinityTerm; the node(s) with
          # the highest sum are the most preferred.
          preferredDuringSchedulingIgnoredDuringExecution:
            # Required. A pod affinity term, associated with the corresponding
            # weight.
            podAffinityTerm:
              # A label query over a set of resources, in this case pods.
              labelSelector:
                # matchExpressions is a list of label selector requirements. The
                # requirements are ANDed.
                matchExpressions:
                  # key is the label key that the selector applies to.
                  key: null
                  # operator represents a key's relationship to a set of values.
                  # Valid operators are In, NotIn, Exists and DoesNotExist.
                  operator: null
                  # values is an array of string values. If the operator is In
                  # or NotIn, the values array must be non-empty. If the
                  # operator is Exists or DoesNotExist, the values array must be
                  # empty. This array is replaced during a strategic merge
                  # patch.
                  values: null
                # matchLabels is a map of {key,value} pairs. A single
                # {key,value} in the matchLabels map is equivalent to an element
                # of matchExpressions, whose key field is "key", the operator is
                # "In", and the values array contains only "value". The
                # requirements are ANDed.
                matchLabels: null
              # namespaces specifies which namespaces the labelSelector applies
              # to (matches against); null or empty list means "this pod's
              # namespace"
              namespaces: null
              # This pod should be co-located (affinity) or not co-located
              # (anti-affinity) with the pods matching the labelSelector in the
              # specified namespaces, where co-located is defined as running on
              # a node whose value of the label with key topologyKey matches
              # that of any node on which any of the selected pods is running.
              # Empty topologyKey is not allowed.
              topologyKey: null
            # weight associated with matching the corresponding podAffinityTerm,
            # in the range 1-100.
            weight: null
          # If the anti-affinity requirements specified by this field are not
          # met at scheduling time, the pod will not be scheduled onto the node.
          # If the anti-affinity requirements specified by this field cease to
          # be met at some point during pod execution (e.g. due to a pod label
          # update), the system may or may not try to eventually evict the pod
          # from its node. When there are multiple elements, the lists of nodes
          # corresponding to each podAffinityTerm are intersected, i.e. all
          # terms must be satisfied.
          requiredDuringSchedulingIgnoredDuringExecution:
            # A label query over a set of resources, in this case pods.
            labelSelector:
              # matchExpressions is a list of label selector requirements. The
              # requirements are ANDed.
              matchExpressions:
                # key is the label key that the selector applies to.
                key: null
                # operator represents a key's relationship to a set of values.
                # Valid operators are In, NotIn, Exists and DoesNotExist.
                operator: null
                # values is an array of string values. If the operator is In or
                # NotIn, the values array must be non-empty. If the operator is
                # Exists or DoesNotExist, the values array must be empty. This
                # array is replaced during a strategic merge patch.
                values: null
              # matchLabels is a map of {key,value} pairs. A single {key,value}
              # in the matchLabels map is equivalent to an element of
              # matchExpressions, whose key field is "key", the operator is
              # "In", and the values array contains only "value". The
              # requirements are ANDed.
              matchLabels: null
            # namespaces specifies which namespaces the labelSelector applies to
            # (matches against); null or empty list means "this pod's namespace"
            namespaces: null
            # This pod should be co-located (affinity) or not co-located (anti-
            # affinity) with the pods matching the labelSelector in the
            # specified namespaces, where co-located is defined as running on a
            # node whose value of the label with key topologyKey matches that of
            # any node on which any of the selected pods is running. Empty
            # topologyKey is not allowed.
            topologyKey: null
      # AutomountServiceAccountToken indicates whether a service account token
      # should be automatically mounted.
      automountServiceAccountToken: null
      # Specifies the DNS parameters of a pod. Parameters specified here will be
      # merged to the generated DNS configuration based on DNSPolicy.
      dnsConfig:
        # A list of DNS name server IP addresses. This will be appended to the
        # base nameservers generated from DNSPolicy. Duplicated nameservers will
        # be removed.
        nameservers: null
        # A list of DNS resolver options. This will be merged with the base
        # options generated from DNSPolicy. Duplicated entries will be removed.
        # Resolution options given in Options will override those that appear in
        # the base DNSPolicy.
        options:
          # Required.
          name: null
          value: null
        # A list of DNS search domains for host-name lookup. This will be
        # appended to the base search paths generated from DNSPolicy. Duplicated
        # search paths will be removed.
        searches: null
      # Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
      # 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS
      # parameters given in DNSConfig will be merged with the policy selected
      # with DNSPolicy. To have DNS options set along with hostNetwork, you have
      # to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
      dnsPolicy: null
      # EnableServiceLinks indicates whether information about services should
      # be injected into pod's environment variables, matching the syntax of
      # Docker links. Optional: Defaults to true.
      enableServiceLinks: null
      # List of ephemeral containers run in this pod. Ephemeral containers may
      # be run in an existing pod to perform user-initiated actions such as
      # debugging. This list cannot be specified when creating a pod, and it
      # cannot be modified by updating the pod spec. In order to add an
      # ephemeral container to an existing pod, use the pod's
      # ephemeralcontainers subresource. This field is alpha-level and is only
      # honored by servers that enable the EphemeralContainers feature.
      ephemeralContainers:
        # Arguments to the entrypoint. The docker image's CMD is used if this is
        # not provided. Variable references $(VAR_NAME) are expanded using the
        # container's environment. If a variable cannot be resolved, the
        # reference in the input string will be unchanged. The $(VAR_NAME)
        # syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
        # references will never be expanded, regardless of whether the variable
        # exists or not. Cannot be updated. More info:
        # https://kubernetes.io/docs/tasks/inject-data-application/define-
        # command-argument-container/#running-a-command-in-a-shell
        args: null
        # Entrypoint array. Not executed within a shell. The docker image's
        # ENTRYPOINT is used if this is not provided. Variable references
        # $(VAR_NAME) are expanded using the container's environment. If a
        # variable cannot be resolved, the reference in the input string will be
        # unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie:
        # $$(VAR_NAME). Escaped references will never be expanded, regardless of
        # whether the variable exists or not. Cannot be updated. More info:
        # https://kubernetes.io/docs/tasks/inject-data-application/define-
        # command-argument-container/#running-a-command-in-a-shell
        command: null
        # List of environment variables to set in the container. Cannot be
        # updated.
        env:
          # Name of the environment variable. Must be a C_IDENTIFIER.
          name: null
          # Variable references $(VAR_NAME) are expanded using the previous
          # defined environment variables in the container and any service
          # environment variables. If a variable cannot be resolved, the
          # reference in the input string will be unchanged. The $(VAR_NAME)
          # syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
          # references will never be expanded, regardless of whether the
          # variable exists or not. Defaults to "".
          value: null
          # Source for the environment variable's value. Cannot be used if value
          # is not empty.
          valueFrom:
            # Selects a key of a ConfigMap.
            configMapKeyRef:
              # The key to select.
              key: null
              # Name of the referent. More info:
              # https://kubernetes.io/docs/concepts/overview/working-with-
              # objects/names/#names TODO: Add other useful fields. apiVersion,
              # kind, uid?
              name: null
              # Specify whether the ConfigMap or its key must be defined
              optional: null
            # Selects a field of the pod: supports metadata.name,
            # metadata.namespace, `metadata.labels['<KEY>']`,
            # `metadata.annotations['<KEY>']`, spec.nodeName,
            # spec.serviceAccountName, status.hostIP, status.podIP,
            # status.podIPs.
            fieldRef:
              # Version of the schema the FieldPath is written in terms of,
              # defaults to "v1".
              apiVersion: null
              # Path of the field to select in the specified API version.
              fieldPath: null
            # Selects a resource of the container: only resources limits and
            # requests (limits.cpu, limits.memory, limits.ephemeral-storage,
            # requests.cpu, requests.memory and requests.ephemeral-storage) are
            # currently supported.
            resourceFieldRef:
              # Container name: required for volumes, optional for env vars
              containerName: null
              # Specifies the output format of the exposed resources, defaults
              # to "1"
              divisor: null
              # Required: resource to select
              resource: null
            # Selects a key of a secret in the pod's namespace
            secretKeyRef:
              # The key of the secret to select from.  Must be a valid secret
              # key.
              key: null
              # Name of the referent. More info:
              # https://kubernetes.io/docs/concepts/overview/working-with-
              # objects/names/#names TODO: Add other useful fields. apiVersion,
              # kind, uid?
              name: null
              # Specify whether the Secret or its key must be defined
              optional: null
        # List of sources to populate environment variables in the container.
        # The keys defined within a source must be a C_IDENTIFIER. All invalid
        # keys will be reported as an event when the container is starting. When
        # a key exists in multiple sources, the value associated with the last
        # source will take precedence. Values defined by an Env with a duplicate
        # key will take precedence. Cannot be updated.
        envFrom:
          # The ConfigMap to select from
          configMapRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
            # Specify whether the ConfigMap must be defined
            optional: null
          # An optional identifier to prepend to each key in the ConfigMap. Must
          # be a C_IDENTIFIER.
          prefix: null
          # The Secret to select from
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
            # Specify whether the Secret must be defined
            optional: null
        # Docker image name. More info:
        # https://kubernetes.io/docs/concepts/containers/images
        image: null
        # Image pull policy. One of Always, Never, IfNotPresent. Defaults to
        # Always if :latest tag is specified, or IfNotPresent otherwise. Cannot
        # be updated. More info:
        # https://kubernetes.io/docs/concepts/containers/images#updating-images
        imagePullPolicy: null
        # Lifecycle is not allowed for ephemeral containers.
        lifecycle:
          # PostStart is called immediately after a container is created. If the
          # handler fails, the container is terminated and restarted according
          # to its restart policy. Other management of the container blocks
          # until the hook completes. More info:
          # https://kubernetes.io/docs/concepts/containers/container-lifecycle-
          # hooks/#container-hooks
          postStart:
            # One and only one of the following should be specified. Exec
            # specifies the action to take.
            exec:
              # Command is the command line to execute inside the container, the
              # working directory for the command  is root ('/') in the
              # container's filesystem. The command is simply exec'd, it is not
              # run inside a shell, so traditional shell instructions ('|', etc)
              # won't work. To use a shell, you need to explicitly call out to
              # that shell. Exit status of 0 is treated as live/healthy and non-
              # zero is unhealthy.
              command: null
            # HTTPGet specifies the http request to perform.
            httpGet:
              # Host name to connect to, defaults to the pod IP. You probably
              # want to set "Host" in httpHeaders instead.
              host: null
              # Custom headers to set in the request. HTTP allows repeated
              # headers.
              httpHeaders:
                # The header field name
                name: null
                # The header field value
                value: null
              # Path to access on the HTTP server.
              path: null
              # Name or number of the port to access on the container. Number
              # must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
              port: null
              # Scheme to use for connecting to the host. Defaults to HTTP.
              scheme: null
            # TCPSocket specifies an action involving a TCP port. TCP hooks not
            # yet supported TODO: implement a realistic TCP lifecycle hook
            tcpSocket:
              # Optional: Host name to connect to, defaults to the pod IP.
              host: null
              # Number or name of the port to access on the container. Number
              # must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
              port: null
          # PreStop is called immediately before a container is terminated due
          # to an API request or management event such as liveness/startup probe
          # failure, preemption, resource contention, etc. The handler is not
          # called if the container crashes or exits. The reason for termination
          # is passed to the handler. The Pod's termination grace period
          # countdown begins before the PreStop hooked is executed. Regardless
          # of the outcome of the handler, the container will eventually
          # terminate within the Pod's termination grace period. Other
          # management of the container blocks until the hook completes or until
          # the termination grace period is reached. More info:
          # https://kubernetes.io/docs/concepts/containers/container-lifecycle-
          # hooks/#container-hooks
          preStop:
            # One and only one of the following should be specified. Exec
            # specifies the action to take.
            exec:
              # Command is the command line to execute inside the container, the
              # working directory for the command  is root ('/') in the
              # container's filesystem. The command is simply exec'd, it is not
              # run inside a shell, so traditional shell instructions ('|', etc)
              # won't work. To use a shell, you need to explicitly call out to
              # that shell. Exit status of 0 is treated as live/healthy and non-
              # zero is unhealthy.
              command: null
            # HTTPGet specifies the http request to perform.
            httpGet:
              # Host name to connect to, defaults to the pod IP. You probably
              # want to set "Host" in httpHeaders instead.
              host: null
              # Custom headers to set in the request. HTTP allows repeated
              # headers.
              httpHeaders:
                # The header field name
                name: null
                # The header field value
                value: null
              # Path to access on the HTTP server.
              path: null
              # Name or number of the port to access on the container. Number
              # must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
              port: null
              # Scheme to use for connecting to the host. Defaults to HTTP.
              scheme: null
            # TCPSocket specifies an action involving a TCP port. TCP hooks not
            # yet supported TODO: implement a realistic TCP lifecycle hook
            tcpSocket:
              # Optional: Host name to connect to, defaults to the pod IP.
              host: null
              # Number or name of the port to access on the container. Number
              # must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
              port: null
        # Probes are not allowed for ephemeral containers.
        livenessProbe:
          # One and only one of the following should be specified. Exec
          # specifies the action to take.
          exec:
            # Command is the command line to execute inside the container, the
            # working directory for the command  is root ('/') in the
            # container's filesystem. The command is simply exec'd, it is not
            # run inside a shell, so traditional shell instructions ('|', etc)
            # won't work. To use a shell, you need to explicitly call out to
            # that shell. Exit status of 0 is treated as live/healthy and non-
            # zero is unhealthy.
            command: null
          # Minimum consecutive failures for the probe to be considered failed
          # after having succeeded. Defaults to 3. Minimum value is 1.
          failureThreshold: null
          # HTTPGet specifies the http request to perform.
          httpGet:
            # Host name to connect to, defaults to the pod IP. You probably want
            # to set "Host" in httpHeaders instead.
            host: null
            # Custom headers to set in the request. HTTP allows repeated
            # headers.
            httpHeaders:
              # The header field name
              name: null
              # The header field value
              value: null
            # Path to access on the HTTP server.
            path: null
            # Name or number of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
            # Scheme to use for connecting to the host. Defaults to HTTP.
            scheme: null
          # Number of seconds after the container has started before liveness
          # probes are initiated. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          initialDelaySeconds: null
          # How often (in seconds) to perform the probe. Default to 10 seconds.
          # Minimum value is 1.
          periodSeconds: null
          # Minimum consecutive successes for the probe to be considered
          # successful after having failed. Defaults to 1. Must be 1 for
          # liveness and startup. Minimum value is 1.
          successThreshold: null
          # TCPSocket specifies an action involving a TCP port. TCP hooks not
          # yet supported TODO: implement a realistic TCP lifecycle hook
          tcpSocket:
            # Optional: Host name to connect to, defaults to the pod IP.
            host: null
            # Number or name of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
          # Number of seconds after which the probe times out. Defaults to 1
          # second. Minimum value is 1. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          timeoutSeconds: null
        # Name of the ephemeral container specified as a DNS_LABEL. This name
        # must be unique among all containers, init containers and ephemeral
        # containers.
        name: null
        # Ports are not allowed for ephemeral containers.
        ports:
          # Number of port to expose on the pod's IP address. This must be a
          # valid port number, 0 < x < 65536.
          containerPort: null
          # What host IP to bind the external port to.
          hostIP: null
          # Number of port to expose on the host. If specified, this must be a
          # valid port number, 0 < x < 65536. If HostNetwork is specified, this
          # must match ContainerPort. Most containers do not need this.
          hostPort: null
          # If specified, this must be an IANA_SVC_NAME and unique within the
          # pod. Each named port in a pod must have a unique name. Name for the
          # port that can be referred to by services.
          name: null
          # Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
          protocol: null
        # Probes are not allowed for ephemeral containers.
        readinessProbe:
          # One and only one of the following should be specified. Exec
          # specifies the action to take.
          exec:
            # Command is the command line to execute inside the container, the
            # working directory for the command  is root ('/') in the
            # container's filesystem. The command is simply exec'd, it is not
            # run inside a shell, so traditional shell instructions ('|', etc)
            # won't work. To use a shell, you need to explicitly call out to
            # that shell. Exit status of 0 is treated as live/healthy and non-
            # zero is unhealthy.
            command: null
          # Minimum consecutive failures for the probe to be considered failed
          # after having succeeded. Defaults to 3. Minimum value is 1.
          failureThreshold: null
          # HTTPGet specifies the http request to perform.
          httpGet:
            # Host name to connect to, defaults to the pod IP. You probably want
            # to set "Host" in httpHeaders instead.
            host: null
            # Custom headers to set in the request. HTTP allows repeated
            # headers.
            httpHeaders:
              # The header field name
              name: null
              # The header field value
              value: null
            # Path to access on the HTTP server.
            path: null
            # Name or number of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
            # Scheme to use for connecting to the host. Defaults to HTTP.
            scheme: null
          # Number of seconds after the container has started before liveness
          # probes are initiated. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          initialDelaySeconds: null
          # How often (in seconds) to perform the probe. Default to 10 seconds.
          # Minimum value is 1.
          periodSeconds: null
          # Minimum consecutive successes for the probe to be considered
          # successful after having failed. Defaults to 1. Must be 1 for
          # liveness and startup. Minimum value is 1.
          successThreshold: null
          # TCPSocket specifies an action involving a TCP port. TCP hooks not
          # yet supported TODO: implement a realistic TCP lifecycle hook
          tcpSocket:
            # Optional: Host name to connect to, defaults to the pod IP.
            host: null
            # Number or name of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
          # Number of seconds after which the probe times out. Defaults to 1
          # second. Minimum value is 1. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          timeoutSeconds: null
        # Resources are not allowed for ephemeral containers. Ephemeral
        # containers use spare resources already allocated to the pod.
        resources:
          # Limits describes the maximum amount of compute resources allowed.
          # More info: https://kubernetes.io/docs/concepts/configuration/manage-
          # compute-resources-container/
          limits: null
          # Requests describes the minimum amount of compute resources required.
          # If Requests is omitted for a container, it defaults to Limits if
          # that is explicitly specified, otherwise to an implementation-defined
          # value. More info:
          # https://kubernetes.io/docs/concepts/configuration/manage-compute-
          # resources-container/
          requests: null
        # SecurityContext is not allowed for ephemeral containers.
        securityContext:
          # AllowPrivilegeEscalation controls whether a process can gain more
          # privileges than its parent process. This bool directly controls if
          # the no_new_privs flag will be set on the container process.
          # AllowPrivilegeEscalation is true always when the container is: 1)
          # run as Privileged 2) has CAP_SYS_ADMIN
          allowPrivilegeEscalation: null
          # The capabilities to add/drop when running containers. Defaults to
          # the default set of capabilities granted by the container runtime.
          capabilities:
            # Added capabilities
            add: null
            # Removed capabilities
            drop: null
          # Run container in privileged mode. Processes in privileged containers
          # are essentially equivalent to root on the host. Defaults to false.
          privileged: null
          # procMount denotes the type of proc mount to use for the containers.
          # The default is DefaultProcMount which uses the container runtime
          # defaults for readonly paths and masked paths. This requires the
          # ProcMountType feature flag to be enabled.
          procMount: null
          # Whether this container has a read-only root filesystem. Default is
          # false.
          readOnlyRootFilesystem: null
          # The GID to run the entrypoint of the container process. Uses runtime
          # default if unset. May also be set in PodSecurityContext.  If set in
          # both SecurityContext and PodSecurityContext, the value specified in
          # SecurityContext takes precedence.
          runAsGroup: null
          # Indicates that the container must run as a non-root user. If true,
          # the Kubelet will validate the image at runtime to ensure that it
          # does not run as UID 0 (root) and fail to start the container if it
          # does. If unset or false, no such validation will be performed. May
          # also be set in PodSecurityContext.  If set in both SecurityContext
          # and PodSecurityContext, the value specified in SecurityContext takes
          # precedence.
          runAsNonRoot: null
          # The UID to run the entrypoint of the container process. Defaults to
          # user specified in image metadata if unspecified. May also be set in
          # PodSecurityContext.  If set in both SecurityContext and
          # PodSecurityContext, the value specified in SecurityContext takes
          # precedence.
          runAsUser: null
          # The SELinux context to be applied to the container. If unspecified,
          # the container runtime will allocate a random SELinux context for
          # each container.  May also be set in PodSecurityContext.  If set in
          # both SecurityContext and PodSecurityContext, the value specified in
          # SecurityContext takes precedence.
          seLinuxOptions:
            # Level is SELinux level label that applies to the container.
            level: null
            # Role is a SELinux role label that applies to the container.
            role: null
            # Type is a SELinux type label that applies to the container.
            type: null
            # User is a SELinux user label that applies to the container.
            user: null
          # The seccomp options to use by this container. If seccomp options are
          # provided at both the pod & container level, the container options
          # override the pod options.
          seccompProfile:
            # localhostProfile indicates a profile defined in a file on the node
            # should be used. The profile must be preconfigured on the node to
            # work. Must be a descending path, relative to the kubelet's
            # configured seccomp profile location. Must only be set if type is
            # "Localhost".
            localhostProfile: null
            # type indicates which kind of seccomp profile will be applied.
            # Valid options are:   Localhost - a profile defined in a file on
            # the node should be used. RuntimeDefault - the container runtime
            # default profile should be used. Unconfined - no profile should be
            # applied.
            type: null
          # The Windows specific settings applied to all containers. If
          # unspecified, the options from the PodSecurityContext will be used.
          # If set in both SecurityContext and PodSecurityContext, the value
          # specified in SecurityContext takes precedence.
          windowsOptions:
            # GMSACredentialSpec is where the GMSA admission webhook
            # (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
            # contents of the GMSA credential spec named by the
            # GMSACredentialSpecName field.
            gmsaCredentialSpec: null
            # GMSACredentialSpecName is the name of the GMSA credential spec to
            # use.
            gmsaCredentialSpecName: null
            # The UserName in Windows to run the entrypoint of the container
            # process. Defaults to the user specified in image metadata if
            # unspecified. May also be set in PodSecurityContext. If set in both
            # SecurityContext and PodSecurityContext, the value specified in
            # SecurityContext takes precedence.
            runAsUserName: null
        # Probes are not allowed for ephemeral containers.
        startupProbe:
          # One and only one of the following should be specified. Exec
          # specifies the action to take.
          exec:
            # Command is the command line to execute inside the container, the
            # working directory for the command  is root ('/') in the
            # container's filesystem. The command is simply exec'd, it is not
            # run inside a shell, so traditional shell instructions ('|', etc)
            # won't work. To use a shell, you need to explicitly call out to
            # that shell. Exit status of 0 is treated as live/healthy and non-
            # zero is unhealthy.
            command: null
          # Minimum consecutive failures for the probe to be considered failed
          # after having succeeded. Defaults to 3. Minimum value is 1.
          failureThreshold: null
          # HTTPGet specifies the http request to perform.
          httpGet:
            # Host name to connect to, defaults to the pod IP. You probably want
            # to set "Host" in httpHeaders instead.
            host: null
            # Custom headers to set in the request. HTTP allows repeated
            # headers.
            httpHeaders:
              # The header field name
              name: null
              # The header field value
              value: null
            # Path to access on the HTTP server.
            path: null
            # Name or number of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
            # Scheme to use for connecting to the host. Defaults to HTTP.
            scheme: null
          # Number of seconds after the container has started before liveness
          # probes are initiated. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          initialDelaySeconds: null
          # How often (in seconds) to perform the probe. Default to 10 seconds.
          # Minimum value is 1.
          periodSeconds: null
          # Minimum consecutive successes for the probe to be considered
          # successful after having failed. Defaults to 1. Must be 1 for
          # liveness and startup. Minimum value is 1.
          successThreshold: null
          # TCPSocket specifies an action involving a TCP port. TCP hooks not
          # yet supported TODO: implement a realistic TCP lifecycle hook
          tcpSocket:
            # Optional: Host name to connect to, defaults to the pod IP.
            host: null
            # Number or name of the port to access on the container. Number must
            # be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
            port: null
          # Number of seconds after which the probe times out. Defaults to 1
          # second. Minimum value is 1. More info:
          # https://kubernetes.io/docs/concepts/workloads/pods/pod-
          # lifecycle#container-probes
          timeoutSeconds: null
        # Whether this container should allocate a buffer for stdin in the
        # container runtime. If this is not set, reads from stdin in the
        # container will always result in EOF. Default is false.
        stdin: null
        # Whether the container runtime should close the stdin channel after it
        # has been opened by a single attach. When stdin is true the stdin
        # stream will remain open across multiple attach sessions. If stdinOnce
        # is set to true, stdin is opened on container start, is empty until the
        # first client attaches to stdin, and then remains open and accepts data
        # until the client disconnects, at which time stdin is closed and
        # remains closed until the container is restarted. If this flag is
        # false, a container processes that reads from stdin will never receive
        # an EOF. Default is false
        stdinOnce: null
        # If set, the name of the container from PodSpec that this ephemeral
        # container targets. The ephemeral container will be run in the
        # namespaces (IPC, PID, etc) of this container. If not set then the
        # ephemeral container is run in whatever namespaces are shared for the
        # pod. Note that the container runtime must support this feature.
        targetContainerName: null
        # Optional: Path at which the file to which the container's termination
        # message will be written is mounted into the container's filesystem.
        # Message written is intended to be brief final status, such as an
        # assertion failure message. Will be truncated by the node if greater
        # than 4096 bytes. The total message length across all containers will
        # be limited to 12kb. Defaults to /dev/termination-log. Cannot be
        # updated.
        terminationMessagePath: null
        # Indicate how the termination message should be populated. File will
        # use the contents of terminationMessagePath to populate the container
        # status message on both success and failure. FallbackToLogsOnError will
        # use the last chunk of container log output if the termination message
        # file is empty and the container exited with an error. The log output
        # is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults
        # to File. Cannot be updated.
        terminationMessagePolicy: null
        # Whether this container should allocate a TTY for itself, also requires
        # 'stdin' to be true. Default is false.
        tty: null
        # volumeDevices is the list of block devices to be used by the
        # container.
        volumeDevices:
          # devicePath is the path inside of the container that the device will
          # be mapped to.
          devicePath: null
          # name must match the name of a persistentVolumeClaim in the pod
          name: null
        # Pod volumes to mount into the container's filesystem. Cannot be
        # updated.
        volumeMounts:
          # Path within the container at which the volume should be mounted.
          # Must not contain ':'.
          mountPath: null
          # mountPropagation determines how mounts are propagated from the host
          # to container and the other way around. When not set,
          # MountPropagationNone is used. This field is beta in 1.10.
          mountPropagation: null
          # This must match the Name of a Volume.
          name: null
          # Mounted read-only if true, read-write otherwise (false or
          # unspecified). Defaults to false.
          readOnly: null
          # Path within the volume from which the container's volume should be
          # mounted. Defaults to "" (volume's root).
          subPath: null
          # Expanded path within the volume from which the container's volume
          # should be mounted. Behaves similarly to SubPath but environment
          # variable references $(VAR_NAME) are expanded using the container's
          # environment. Defaults to "" (volume's root). SubPathExpr and SubPath
          # are mutually exclusive.
          subPathExpr: null
        # Container's working directory. If not specified, the container
        # runtime's default will be used, which might be configured in the
        # container image. Cannot be updated.
        workingDir: null
      # HostAliases is an optional list of hosts and IPs that will be injected
      # into the pod's hosts file if specified. This is only valid for non-
      # hostNetwork pods.
      hostAliases:
        # Hostnames for the above IP address.
        hostnames: null
        # IP address of the host file entry.
        ip: null
      # Use the host's ipc namespace. Optional: Default to false.
      hostIPC: null
      # Host networking requested for this pod. Use the host's network
      # namespace. If this option is set, the ports that will be used must be
      # specified. Default to false.
      hostNetwork: null
      # Use the host's pid namespace. Optional: Default to false.
      hostPID: null
      # Specifies the hostname of the Pod If not specified, the pod's hostname
      # will be set to a system-defined value.
      hostname: null
      # ImagePullSecrets is an optional list of references to secrets in the
      # same namespace to use for pulling any of the images used by this
      # PodSpec. If specified, these secrets will be passed to individual puller
      # implementations for them to use. For example, in the case of docker,
      # only DockerConfig type secrets are honored. More info:
      # https://kubernetes.io/docs/concepts/containers/images#specifying-
      # imagepullsecrets-on-a-pod
      imagePullSecrets:
        # Name of the referent. More info:
        # https://kubernetes.io/docs/concepts/overview/working-with-
        # objects/names/#names TODO: Add other useful fields. apiVersion, kind,
        # uid?
        name: null
      # NodeName is a request to schedule this pod onto a specific node. If it
      # is non-empty, the scheduler simply schedules this pod onto that node,
      # assuming that it fits resource requirements.
      nodeName: null
      # NodeSelector is a selector which must be true for the pod to fit on a
      # node. Selector which must match a node's labels for the pod to be
      # scheduled on that node. More info:
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
      nodeSelector: null
      # Overhead represents the resource overhead associated with running a pod
      # for a given RuntimeClass. This field will be autopopulated at admission
      # time by the RuntimeClass admission controller. If the RuntimeClass
      # admission controller is enabled, overhead must not be set in Pod create
      # requests. The RuntimeClass admission controller will reject Pod create
      # requests which have the overhead already set. If RuntimeClass is
      # configured and selected in the PodSpec, Overhead will be set to the
      # value defined in the corresponding RuntimeClass, otherwise it will
      # remain unset and treated as zero. More info:
      # https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md
      # This field is alpha-level as of Kubernetes v1.16, and is only honored by
      # servers that enable the PodOverhead feature.
      overhead: null
      # PreemptionPolicy is the Policy for preempting pods with lower priority.
      # One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if
      # unset. This field is beta-level, gated by the NonPreemptingPriority
      # feature-gate.
      preemptionPolicy: null
      # The priority value. Various system components use this field to find the
      # priority of the pod. When Priority Admission Controller is enabled, it
      # prevents users from setting this field. The admission controller
      # populates this field from PriorityClassName. The higher the value, the
      # higher the priority.
      priority: null
      # If specified, indicates the pod's priority. "system-node-critical" and
      # "system-cluster-critical" are two special keywords which indicate the
      # highest priorities with the former being the highest priority. Any other
      # name must be defined by creating a PriorityClass object with that name.
      # If not specified, the pod priority will be default or zero if there is
      # no default.
      priorityClassName: null
      # If specified, all readiness gates will be evaluated for pod readiness. A
      # pod is ready when all its containers are ready AND all conditions
      # specified in the readiness gates have status equal to "True" More info:
      # https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
      readinessGates:
        # ConditionType refers to a condition in the pod's condition list with
        # matching type.
        conditionType: null
      # Restart policy for all containers within the pod. One of Always,
      # OnFailure, Never. Default to Always. More info:
      # https://kubernetes.io/docs/concepts/workloads/pods/pod-
      # lifecycle/#restart-policy
      restartPolicy: null
      # RuntimeClassName refers to a RuntimeClass object in the node.k8s.io
      # group, which should be used to run this pod.  If no RuntimeClass
      # resource matches the named class, the pod will not be run. If unset or
      # empty, the "legacy" RuntimeClass will be used, which is an implicit
      # class with an empty definition that uses the default runtime handler.
      # More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-
      # class.md This is a beta feature as of Kubernetes v1.14.
      runtimeClassName: null
      # If specified, the pod will be dispatched by specified scheduler. If not
      # specified, the pod will be dispatched by default scheduler.
      schedulerName: null
      # SecurityContext holds pod-level security attributes and common container
      # settings. Optional: Defaults to empty.  See type description for default
      # values of each field.
      securityContext:
        # A special supplemental group that applies to all containers in a pod.
        # Some volume types allow the Kubelet to change the ownership of that
        # volume to be owned by the pod:   1. The owning GID will be the FSGroup
        # 2. The setgid bit is set (new files created in the volume will be
        # owned by FSGroup) 3. The permission bits are OR'd with rw-rw----   If
        # unset, the Kubelet will not modify the ownership and permissions of
        # any volume.
        fsGroup: null
        # fsGroupChangePolicy defines behavior of changing ownership and
        # permission of the volume before being exposed inside Pod. This field
        # will only apply to volume types which support fsGroup based
        # ownership(and permissions). It will have no effect on ephemeral volume
        # types such as: secret, configmaps and emptydir. Valid values are
        # "OnRootMismatch" and "Always". If not specified defaults to "Always".
        fsGroupChangePolicy: null
        # The GID to run the entrypoint of the container process. Uses runtime
        # default if unset. May also be set in SecurityContext.  If set in both
        # SecurityContext and PodSecurityContext, the value specified in
        # SecurityContext takes precedence for that container.
        runAsGroup: null
        # Indicates that the container must run as a non-root user. If true, the
        # Kubelet will validate the image at runtime to ensure that it does not
        # run as UID 0 (root) and fail to start the container if it does. If
        # unset or false, no such validation will be performed. May also be set
        # in SecurityContext.  If set in both SecurityContext and
        # PodSecurityContext, the value specified in SecurityContext takes
        # precedence.
        runAsNonRoot: null
        # The UID to run the entrypoint of the container process. Defaults to
        # user specified in image metadata if unspecified. May also be set in
        # SecurityContext.  If set in both SecurityContext and
        # PodSecurityContext, the value specified in SecurityContext takes
        # precedence for that container.
        runAsUser: null
        # The SELinux context to be applied to all containers. If unspecified,
        # the container runtime will allocate a random SELinux context for each
        # container.  May also be set in SecurityContext.  If set in both
        # SecurityContext and PodSecurityContext, the value specified in
        # SecurityContext takes precedence for that container.
        seLinuxOptions:
          # Level is SELinux level label that applies to the container.
          level: null
          # Role is a SELinux role label that applies to the container.
          role: null
          # Type is a SELinux type label that applies to the container.
          type: null
          # User is a SELinux user label that applies to the container.
          user: null
        # The seccomp options to use by the containers in this pod.
        seccompProfile:
          # localhostProfile indicates a profile defined in a file on the node
          # should be used. The profile must be preconfigured on the node to
          # work. Must be a descending path, relative to the kubelet's
          # configured seccomp profile location. Must only be set if type is
          # "Localhost".
          localhostProfile: null
          # type indicates which kind of seccomp profile will be applied. Valid
          # options are:   Localhost - a profile defined in a file on the node
          # should be used. RuntimeDefault - the container runtime default
          # profile should be used. Unconfined - no profile should be applied.
          type: null
        # A list of groups applied to the first process run in each container,
        # in addition to the container's primary GID.  If unspecified, no groups
        # will be added to any container.
        supplementalGroups: null
        # Sysctls hold a list of namespaced sysctls used for the pod. Pods with
        # unsupported sysctls (by the container runtime) might fail to launch.
        sysctls:
          # Name of a property to set
          name: null
          # Value of a property to set
          value: null
        # The Windows specific settings applied to all containers. If
        # unspecified, the options within a container's SecurityContext will be
        # used. If set in both SecurityContext and PodSecurityContext, the value
        # specified in SecurityContext takes precedence.
        windowsOptions:
          # GMSACredentialSpec is where the GMSA admission webhook
          # (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
          # contents of the GMSA credential spec named by the
          # GMSACredentialSpecName field.
          gmsaCredentialSpec: null
          # GMSACredentialSpecName is the name of the GMSA credential spec to
          # use.
          gmsaCredentialSpecName: null
          # The UserName in Windows to run the entrypoint of the container
          # process. Defaults to the user specified in image metadata if
          # unspecified. May also be set in PodSecurityContext. If set in both
          # SecurityContext and PodSecurityContext, the value specified in
          # SecurityContext takes precedence.
          runAsUserName: null
      # DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
      # Deprecated: Use serviceAccountName instead.
      serviceAccount: null
      # ServiceAccountName is the name of the ServiceAccount to use to run this
      # pod. More info: https://kubernetes.io/docs/tasks/configure-pod-
      # container/configure-service-account/
      serviceAccountName: null
      # If true the pod's hostname will be configured as the pod's FQDN, rather
      # than the leaf name (the default). In Linux containers, this means
      # setting the FQDN in the hostname field of the kernel (the nodename field
      # of struct utsname). In Windows containers, this means setting the
      # registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYST
      # EM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod
      # does not have FQDN, this has no effect. Default to false.
      setHostnameAsFQDN: null
      # Share a single process namespace between all of the containers in a pod.
      # When this is set containers will be able to view and signal processes
      # from other containers in the same pod, and the first process in each
      # container will not be assigned PID 1. HostPID and ShareProcessNamespace
      # cannot both be set. Optional: Default to false.
      shareProcessNamespace: null
      # If specified, the fully qualified Pod hostname will be
      # "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not
      # specified, the pod will not have a domainname at all.
      subdomain: null
      # Optional duration in seconds the pod needs to terminate gracefully. May
      # be decreased in delete request. Value must be non-negative integer. The
      # value zero indicates delete immediately. If this value is nil, the
      # default grace period will be used instead. The grace period is the
      # duration in seconds after the processes running in the pod are sent a
      # termination signal and the time when the processes are forcibly halted
      # with a kill signal. Set this value longer than the expected cleanup time
      # for your process. Defaults to 30 seconds.
      terminationGracePeriodSeconds: null
      # If specified, the pod's tolerations.
      tolerations:
        # Effect indicates the taint effect to match. Empty means match all
        # taint effects. When specified, allowed values are NoSchedule,
        # PreferNoSchedule and NoExecute.
        effect: null
        # Key is the taint key that the toleration applies to. Empty means match
        # all taint keys. If the key is empty, operator must be Exists; this
        # combination means to match all values and all keys.
        key: null
        # Operator represents a key's relationship to the value. Valid operators
        # are Exists and Equal. Defaults to Equal. Exists is equivalent to
        # wildcard for value, so that a pod can tolerate all taints of a
        # particular category.
        operator: null
        # TolerationSeconds represents the period of time the toleration (which
        # must be of effect NoExecute, otherwise this field is ignored)
        # tolerates the taint. By default, it is not set, which means tolerate
        # the taint forever (do not evict). Zero and negative values will be
        # treated as 0 (evict immediately) by the system.
        tolerationSeconds: null
        # Value is the taint value the toleration matches to. If the operator is
        # Exists, the value should be empty, otherwise just a regular string.
        value: null
      # TopologySpreadConstraints describes how a group of pods ought to spread
      # across topology domains. Scheduler will schedule pods in a way which
      # abides by the constraints. All topologySpreadConstraints are ANDed.
      topologySpreadConstraints:
        # LabelSelector is used to find matching pods. Pods that match this
        # label selector are counted to determine the number of pods in their
        # corresponding topology domain.
        labelSelector:
          # matchExpressions is a list of label selector requirements. The
          # requirements are ANDed.
          matchExpressions:
            # key is the label key that the selector applies to.
            key: null
            # operator represents a key's relationship to a set of values. Valid
            # operators are In, NotIn, Exists and DoesNotExist.
            operator: null
            # values is an array of string values. If the operator is In or
            # NotIn, the values array must be non-empty. If the operator is
            # Exists or DoesNotExist, the values array must be empty. This array
            # is replaced during a strategic merge patch.
            values: null
          # matchLabels is a map of {key,value} pairs. A single {key,value} in
          # the matchLabels map is equivalent to an element of matchExpressions,
          # whose key field is "key", the operator is "In", and the values array
          # contains only "value". The requirements are ANDed.
          matchLabels: null
        # MaxSkew describes the degree to which pods may be unevenly
        # distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum
        # permitted difference between the number of matching pods in the target
        # topology and the global minimum. For example, in a 3-zone cluster,
        # MaxSkew is set to 1, and pods with the same labelSelector spread as
        # 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if
        # MaxSkew is 1, incoming pod can only be scheduled to zone3 to become
        # 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0)
        # on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod
        # can be scheduled onto any zone. When
        # `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
        # precedence to topologies that satisfy it. It's a required field.
        # Default value is 1 and 0 is not allowed.
        maxSkew: null
        # TopologyKey is the key of node labels. Nodes that have a label with
        # this key and identical values are considered to be in the same
        # topology. We consider each <key, value> as a "bucket", and try to put
        # balanced number of pods into each bucket. It's a required field.
        topologyKey: null
        # WhenUnsatisfiable indicates how to deal with a pod if it doesn't
        # satisfy the spread constraint. - DoNotSchedule (default) tells the
        # scheduler not to schedule it. - ScheduleAnyway tells the scheduler to
        # schedule the pod in any location,   but giving higher precedence to
        # topologies that would help reduce the   skew. A constraint is
        # considered "Unsatisfiable" for an incoming pod if and only if every
        # possible node assigment for that pod would violate "MaxSkew" on some
        # topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and
        # pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 |
        # zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to
        # DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to
        # become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
        # MaxSkew(1). In other words, the cluster can still be imbalanced, but
        # scheduler won't make it *more* imbalanced. It's a required field.
        whenUnsatisfiable: null
      # List of volumes that can be mounted by containers belonging to the pod.
      # More info: https://kubernetes.io/docs/concepts/storage/volumes
      volumes:
        # AWSElasticBlockStore represents an AWS Disk resource that is attached
        # to a kubelet's host machine and then exposed to the pod. More info: ht
        # tps://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        awsElasticBlockStore:
          # Filesystem type of the volume that you want to mount. Tip: Ensure
          # that the filesystem type is supported by the host operating system.
          # Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
          # unspecified. More info: https://kubernetes.io/docs/concepts/storage/
          # volumes#awselasticblockstore TODO: how do we prevent errors in the
          # filesystem from compromising the machine
          fsType: null
          # The partition in the volume that you want to mount. If omitted, the
          # default is to mount by volume name. Examples: For volume /dev/sda1,
          # you specify the partition as "1". Similarly, the volume partition
          # for /dev/sda is "0" (or you can leave the property empty).
          partition: null
          # Specify "true" to force and set the ReadOnly property in
          # VolumeMounts to "true". If omitted, the default is "false". More
          # info: https://kubernetes.io/docs/concepts/storage/volumes#awselastic
          # blockstore
          readOnly: null
          # Unique ID of the persistent disk resource in AWS (Amazon EBS
          # volume). More info: https://kubernetes.io/docs/concepts/storage/volu
          # mes#awselasticblockstore
          volumeID: null
        # AzureDisk represents an Azure Data Disk mount on the host and bind
        # mount to the pod.
        azureDisk:
          # Host Caching mode: None, Read Only, Read Write.
          cachingMode: null
          # The Name of the data disk in the blob storage
          diskName: null
          # The URI the data disk in the blob storage
          diskURI: null
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified.
          fsType: null
          # Expected values Shared: multiple blob disks per storage account
          # Dedicated: single blob disk per storage account  Managed: azure
          # managed data disk (only in managed availability set). defaults to
          # shared
          kind: null
          # Defaults to false (read/write). ReadOnly here will force the
          # ReadOnly setting in VolumeMounts.
          readOnly: null
        # AzureFile represents an Azure File Service mount on the host and bind
        # mount to the pod.
        azureFile:
          # Defaults to false (read/write). ReadOnly here will force the
          # ReadOnly setting in VolumeMounts.
          readOnly: null
          # the name of secret that contains Azure Storage Account Name and Key
          secretName: null
          # Share Name
          shareName: null
        # CephFS represents a Ceph FS mount on the host that shares a pod's
        # lifetime
        cephfs:
          # Required: Monitors is a collection of Ceph monitors More info:
          # https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
          monitors: null
          # Optional: Used as the mounted root, rather than the full Ceph tree,
          # default is /
          path: null
          # Optional: Defaults to false (read/write). ReadOnly here will force
          # the ReadOnly setting in VolumeMounts. More info:
          # https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
          readOnly: null
          # Optional: SecretFile is the path to key ring for User, default is
          # /etc/ceph/user.secret More info:
          # https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
          secretFile: null
          # Optional: SecretRef is reference to the authentication secret for
          # User, default is empty. More info:
          # https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # Optional: User is the rados user name, default is admin More info:
          # https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
          user: null
        # Cinder represents a cinder volume attached and mounted on kubelets
        # host machine. More info: https://examples.k8s.io/mysql-cinder-
        # pd/README.md
        cinder:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified. More info:
          # https://examples.k8s.io/mysql-cinder-pd/README.md
          fsType: null
          # Optional: Defaults to false (read/write). ReadOnly here will force
          # the ReadOnly setting in VolumeMounts. More info:
          # https://examples.k8s.io/mysql-cinder-pd/README.md
          readOnly: null
          # Optional: points to a secret object containing parameters used to
          # connect to OpenStack.
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # volume id used to identify the volume in cinder. More info:
          # https://examples.k8s.io/mysql-cinder-pd/README.md
          volumeID: null
        # ConfigMap represents a configMap that should populate this volume
        configMap:
          # Optional: mode bits used to set permissions on created files by
          # default. Must be an octal value between 0000 and 0777 or a decimal
          # value between 0 and 511. YAML accepts both octal and decimal values,
          # JSON requires decimal values for mode bits. Defaults to 0644.
          # Directories within the path are not affected by this setting. This
          # might be in conflict with other options that affect the file mode,
          # like fsGroup, and the result can be other mode bits set.
          defaultMode: null
          # If unspecified, each key-value pair in the Data field of the
          # referenced ConfigMap will be projected into the volume as a file
          # whose name is the key and content is the value. If specified, the
          # listed keys will be projected into the specified paths, and unlisted
          # keys will not be present. If a key is specified which is not present
          # in the ConfigMap, the volume setup will error unless it is marked
          # optional. Paths must be relative and may not contain the '..' path
          # or start with '..'.
          items:
            # The key to project.
            key: null
            # Optional: mode bits used to set permissions on this file. Must be
            # an octal value between 0000 and 0777 or a decimal value between 0
            # and 511. YAML accepts both octal and decimal values, JSON requires
            # decimal values for mode bits. If not specified, the volume
            # defaultMode will be used. This might be in conflict with other
            # options that affect the file mode, like fsGroup, and the result
            # can be other mode bits set.
            mode: null
            # The relative path of the file to map the key to. May not be an
            # absolute path. May not contain the path element '..'. May not
            # start with the string '..'.
            path: null
          # Name of the referent. More info:
          # https://kubernetes.io/docs/concepts/overview/working-with-
          # objects/names/#names TODO: Add other useful fields. apiVersion,
          # kind, uid?
          name: null
          # Specify whether the ConfigMap or its keys must be defined
          optional: null
        # CSI (Container Storage Interface) represents ephemeral storage that is
        # handled by certain external CSI drivers (Beta feature).
        csi:
          # Driver is the name of the CSI driver that handles this volume.
          # Consult with your admin for the correct name as registered in the
          # cluster.
          driver: null
          # Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not
          # provided, the empty value is passed to the associated CSI driver
          # which will determine the default filesystem to apply.
          fsType: null
          # NodePublishSecretRef is a reference to the secret object containing
          # sensitive information to pass to the CSI driver to complete the CSI
          # NodePublishVolume and NodeUnpublishVolume calls. This field is
          # optional, and  may be empty if no secret is required. If the secret
          # object contains more than one secret, all secret references are
          # passed.
          nodePublishSecretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # Specifies a read-only configuration for the volume. Defaults to
          # false (read/write).
          readOnly: null
          # VolumeAttributes stores driver-specific properties that are passed
          # to the CSI driver. Consult your driver's documentation for supported
          # values.
          volumeAttributes: null
        # DownwardAPI represents downward API about the pod that should populate
        # this volume
        downwardAPI:
          # Optional: mode bits to use on created files by default. Must be a
          # Optional: mode bits used to set permissions on created files by
          # default. Must be an octal value between 0000 and 0777 or a decimal
          # value between 0 and 511. YAML accepts both octal and decimal values,
          # JSON requires decimal values for mode bits. Defaults to 0644.
          # Directories within the path are not affected by this setting. This
          # might be in conflict with other options that affect the file mode,
          # like fsGroup, and the result can be other mode bits set.
          defaultMode: null
          # Items is a list of downward API volume file
          items:
            # Required: Selects a field of the pod: only annotations, labels,
            # name and namespace are supported.
            fieldRef:
              # Version of the schema the FieldPath is written in terms of,
              # defaults to "v1".
              apiVersion: null
              # Path of the field to select in the specified API version.
              fieldPath: null
            # Optional: mode bits used to set permissions on this file, must be
            # an octal value between 0000 and 0777 or a decimal value between 0
            # and 511. YAML accepts both octal and decimal values, JSON requires
            # decimal values for mode bits. If not specified, the volume
            # defaultMode will be used. This might be in conflict with other
            # options that affect the file mode, like fsGroup, and the result
            # can be other mode bits set.
            mode: null
            # Required: Path is  the relative path name of the file to be
            # created. Must not be absolute or contain the '..' path. Must be
            # utf-8 encoded. The first item of the relative path must not start
            # with '..'
            path: null
            # Selects a resource of the container: only resources limits and
            # requests (limits.cpu, limits.memory, requests.cpu and
            # requests.memory) are currently supported.
            resourceFieldRef:
              # Container name: required for volumes, optional for env vars
              containerName: null
              # Specifies the output format of the exposed resources, defaults
              # to "1"
              divisor: null
              # Required: resource to select
              resource: null
        # EmptyDir represents a temporary directory that shares a pod's
        # lifetime. More info:
        # https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        emptyDir:
          # What type of storage medium should back this directory. The default
          # is "" which means to use the node's default medium. Must be an empty
          # string (default) or Memory. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#emptydir
          medium: null
          # Total amount of local storage required for this EmptyDir volume. The
          # size limit is also applicable for memory medium. The maximum usage
          # on memory medium EmptyDir would be the minimum value between the
          # SizeLimit specified here and the sum of memory limits of all
          # containers in a pod. The default is nil which means that the limit
          # is undefined. More info: http://kubernetes.io/docs/user-
          # guide/volumes#emptydir
          sizeLimit: null
        # Ephemeral represents a volume that is handled by a cluster storage
        # driver (Alpha feature). The volume's lifecycle is tied to the pod that
        # defines it - it will be created before the pod starts, and deleted
        # when the pod is removed.   Use this if: a) the volume is only needed
        # while the pod runs, b) features of normal volumes like restoring from
        # snapshot or capacity    tracking are needed, c) the storage driver is
        # specified through a storage class, and d) the storage driver supports
        # dynamic volume provisioning through    a PersistentVolumeClaim (see
        # EphemeralVolumeSource for more    information on the connection
        # between this volume type    and PersistentVolumeClaim).   Use
        # PersistentVolumeClaim or one of the vendor-specific APIs for volumes
        # that persist for longer than the lifecycle of an individual pod.   Use
        # CSI for light-weight local ephemeral volumes if the CSI driver is
        # meant to be used that way - see the documentation of the driver for
        # more information.   A pod can use both types of ephemeral volumes and
        # persistent volumes at the same time.
        ephemeral:
          # Specifies a read-only configuration for the volume. Defaults to
          # false (read/write).
          readOnly: null
          # Will be used to create a stand-alone PVC to provision the volume.
          # The pod in which this EphemeralVolumeSource is embedded will be the
          # owner of the PVC, i.e. the PVC will be deleted together with the
          # pod.  The name of the PVC will be `<pod name>-<volume name>` where
          # `<volume name>` is the name from the `PodSpec.Volumes` array entry.
          # Pod validation will reject the pod if the concatenated name is not
          # valid for a PVC (for example, too long).   An existing PVC with that
          # name that is not owned by the pod will *not* be used for the pod to
          # avoid using an unrelated volume by mistake. Starting the pod is then
          # blocked until the unrelated PVC is removed. If such a pre-created
          # PVC is meant to be used by the pod, the PVC has to updated with an
          # owner reference to the pod once the pod exists. Normally this should
          # not be necessary, but it may be useful when manually reconstructing
          # a broken cluster.   This field is read-only and no changes will be
          # made by Kubernetes to the PVC after it has been created.   Required,
          # must not be nil.
          volumeClaimTemplate:
            # May contain labels and annotations that will be copied into the
            # PVC when creating it. No other fields are allowed and will be
            # rejected during validation.
            metadata: null
            # The specification for the PersistentVolumeClaim. The entire
            # content is copied unchanged into the PVC that gets created from
            # this template. The same fields as in a PersistentVolumeClaim are
            # also valid here.
            spec:
              # AccessModes contains the desired access modes the volume should
              # have. More info:
              # https://kubernetes.io/docs/concepts/storage/persistent-
              # volumes#access-modes-1
              accessModes: null
              # This field can be used to specify either: * An existing
              # VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot -
              # Beta) * An existing PVC (PersistentVolumeClaim) * An existing
              # custom resource/object that implements data population (Alpha)
              # In order to use VolumeSnapshot object types, the appropriate
              # feature gate must be enabled (VolumeSnapshotDataSource or
              # AnyVolumeDataSource) If the provisioner or an external
              # controller can support the specified data source, it will create
              # a new volume based on the contents of the specified data source.
              # If the specified data source is not supported, the volume will
              # not be created and the failure will be reported as an event. In
              # the future, we plan to support more data source types and the
              # behavior of the provisioner may change.
              dataSource:
                # APIGroup is the group for the resource being referenced. If
                # APIGroup is not specified, the specified Kind must be in the
                # core API group. For any other third-party types, APIGroup is
                # required.
                apiGroup: null
                # Kind is the type of resource being referenced
                kind: null
                # Name is the name of resource being referenced
                name: null
              # Resources represents the minimum resources the volume should
              # have. More info:
              # https://kubernetes.io/docs/concepts/storage/persistent-
              # volumes#resources
              resources:
                # Limits describes the maximum amount of compute resources
                # allowed. More info:
                # https://kubernetes.io/docs/concepts/configuration/manage-
                # compute-resources-container/
                limits: null
                # Requests describes the minimum amount of compute resources
                # required. If Requests is omitted for a container, it defaults
                # to Limits if that is explicitly specified, otherwise to an
                # implementation-defined value. More info:
                # https://kubernetes.io/docs/concepts/configuration/manage-
                # compute-resources-container/
                requests: null
              # A label query over volumes to consider for binding.
              selector:
                # matchExpressions is a list of label selector requirements. The
                # requirements are ANDed.
                matchExpressions:
                  # key is the label key that the selector applies to.
                  key: null
                  # operator represents a key's relationship to a set of values.
                  # Valid operators are In, NotIn, Exists and DoesNotExist.
                  operator: null
                  # values is an array of string values. If the operator is In
                  # or NotIn, the values array must be non-empty. If the
                  # operator is Exists or DoesNotExist, the values array must be
                  # empty. This array is replaced during a strategic merge
                  # patch.
                  values: null
                # matchLabels is a map of {key,value} pairs. A single
                # {key,value} in the matchLabels map is equivalent to an element
                # of matchExpressions, whose key field is "key", the operator is
                # "In", and the values array contains only "value". The
                # requirements are ANDed.
                matchLabels: null
              # Name of the StorageClass required by the claim. More info:
              # https://kubernetes.io/docs/concepts/storage/persistent-
              # volumes#class-1
              storageClassName: null
              # volumeMode defines what type of volume is required by the claim.
              # Value of Filesystem is implied when not included in claim spec.
              volumeMode: null
              # VolumeName is the binding reference to the PersistentVolume
              # backing this claim.
              volumeName: null
        # FC represents a Fibre Channel resource that is attached to a kubelet's
        # host machine and then exposed to the pod.
        fc:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified. TODO: how do we prevent errors
          # in the filesystem from compromising the machine
          fsType: null
          # Optional: FC target lun number
          lun: null
          # Optional: Defaults to false (read/write). ReadOnly here will force
          # the ReadOnly setting in VolumeMounts.
          readOnly: null
          # Optional: FC target worldwide names (WWNs)
          targetWWNs: null
          # Optional: FC volume world wide identifiers (wwids) Either wwids or
          # combination of targetWWNs and lun must be set, but not both
          # simultaneously.
          wwids: null
        # FlexVolume represents a generic volume resource that is
        # provisioned/attached using an exec based plugin.
        flexVolume:
          # Driver is the name of the driver to use for this volume.
          driver: null
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". The default
          # filesystem depends on FlexVolume script.
          fsType: null
          # Optional: Extra command options if any.
          options: null
          # Optional: Defaults to false (read/write). ReadOnly here will force
          # the ReadOnly setting in VolumeMounts.
          readOnly: null
          # Optional: SecretRef is reference to the secret object containing
          # sensitive information to pass to the plugin scripts. This may be
          # empty if no secret object is specified. If the secret object
          # contains more than one secret, all secrets are passed to the plugin
          # scripts.
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
        # Flocker represents a Flocker volume attached to a kubelet's host
        # machine. This depends on the Flocker control service being running
        flocker:
          # Name of the dataset stored as metadata -> name on the dataset for
          # Flocker should be considered as deprecated
          datasetName: null
          # UUID of the dataset. This is unique identifier of a Flocker dataset
          datasetUUID: null
        # GCEPersistentDisk represents a GCE Disk resource that is attached to a
        # kubelet's host machine and then exposed to the pod. More info:
        # https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        gcePersistentDisk:
          # Filesystem type of the volume that you want to mount. Tip: Ensure
          # that the filesystem type is supported by the host operating system.
          # Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
          # unspecified. More info: https://kubernetes.io/docs/concepts/storage/
          # volumes#gcepersistentdisk TODO: how do we prevent errors in the
          # filesystem from compromising the machine
          fsType: null
          # The partition in the volume that you want to mount. If omitted, the
          # default is to mount by volume name. Examples: For volume /dev/sda1,
          # you specify the partition as "1". Similarly, the volume partition
          # for /dev/sda is "0" (or you can leave the property empty). More
          # info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersist
          # entdisk
          partition: null
          # Unique name of the PD resource in GCE. Used to identify the disk in
          # GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#
          # gcepersistentdisk
          pdName: null
          # ReadOnly here will force the ReadOnly setting in VolumeMounts.
          # Defaults to false. More info: https://kubernetes.io/docs/concepts/st
          # orage/volumes#gcepersistentdisk
          readOnly: null
        # GitRepo represents a git repository at a particular revision.
        # DEPRECATED: GitRepo is deprecated. To provision a container with a git
        # repo, mount an EmptyDir into an InitContainer that clones the repo
        # using git, then mount the EmptyDir into the Pod's container.
        gitRepo:
          # Target directory name. Must not contain or start with '..'.  If '.'
          # is supplied, the volume directory will be the git repository.
          # Otherwise, if specified, the volume will contain the git repository
          # in the subdirectory with the given name.
          directory: null
          # Repository URL
          repository: null
          # Commit hash for the specified revision.
          revision: null
        # Glusterfs represents a Glusterfs mount on the host that shares a pod's
        # lifetime. More info:
        # https://examples.k8s.io/volumes/glusterfs/README.md
        glusterfs:
          # EndpointsName is the endpoint name that details Glusterfs topology.
          # More info:
          # https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
          endpoints: null
          # Path is the Glusterfs volume path. More info:
          # https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
          path: null
          # ReadOnly here will force the Glusterfs volume to be mounted with
          # read-only permissions. Defaults to false. More info:
          # https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
          readOnly: null
        # HostPath represents a pre-existing file or directory on the host
        # machine that is directly exposed to the container. This is generally
        # used for system agents or other privileged things that are allowed to
        # see the host machine. Most containers will NOT need this. More info:
        # https://kubernetes.io/docs/concepts/storage/volumes#hostpath ---
        # TODO(jonesdl) We need to restrict who can use host directory mounts
        # and who can/can not mount host directories as read/write.
        hostPath:
          # Path of the directory on the host. If the path is a symlink, it will
          # follow the link to the real path. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#hostpath
          path: null
          # Type for HostPath Volume Defaults to "" More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#hostpath
          type: null
        # ISCSI represents an ISCSI Disk resource that is attached to a
        # kubelet's host machine and then exposed to the pod. More info:
        # https://examples.k8s.io/volumes/iscsi/README.md
        iscsi:
          # whether support iSCSI Discovery CHAP authentication
          chapAuthDiscovery: null
          # whether support iSCSI Session CHAP authentication
          chapAuthSession: null
          # Filesystem type of the volume that you want to mount. Tip: Ensure
          # that the filesystem type is supported by the host operating system.
          # Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
          # unspecified. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how
          # do we prevent errors in the filesystem from compromising the machine
          fsType: null
          # Custom iSCSI Initiator Name. If initiatorName is specified with
          # iscsiInterface simultaneously, new iSCSI interface <target
          # portal>:<volume name> will be created for the connection.
          initiatorName: null
          # Target iSCSI Qualified Name.
          iqn: null
          # iSCSI Interface Name that uses an iSCSI transport. Defaults to
          # 'default' (tcp).
          iscsiInterface: null
          # iSCSI Target Lun number.
          lun: null
          # iSCSI Target Portal List. The portal is either an IP or ip_addr:port
          # if the port is other than default (typically TCP ports 860 and
          # 3260).
          portals: null
          # ReadOnly here will force the ReadOnly setting in VolumeMounts.
          # Defaults to false.
          readOnly: null
          # CHAP Secret for iSCSI target and initiator authentication
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # iSCSI Target Portal. The Portal is either an IP or ip_addr:port if
          # the port is other than default (typically TCP ports 860 and 3260).
          targetPortal: null
        # Volume's name. Must be a DNS_LABEL and unique within the pod. More
        # info: https://kubernetes.io/docs/concepts/overview/working-with-
        # objects/names/#names
        name: null
        # NFS represents an NFS mount on the host that shares a pod's lifetime
        # More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        nfs:
          # Path that is exported by the NFS server. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#nfs
          path: null
          # ReadOnly here will force the NFS export to be mounted with read-only
          # permissions. Defaults to false. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#nfs
          readOnly: null
          # Server is the hostname or IP address of the NFS server. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#nfs
          server: null
        # PersistentVolumeClaimVolumeSource represents a reference to a
        # PersistentVolumeClaim in the same namespace. More info:
        # https://kubernetes.io/docs/concepts/storage/persistent-
        # volumes#persistentvolumeclaims
        persistentVolumeClaim:
          # ClaimName is the name of a PersistentVolumeClaim in the same
          # namespace as the pod using this volume. More info:
          # https://kubernetes.io/docs/concepts/storage/persistent-
          # volumes#persistentvolumeclaims
          claimName: null
          # Will force the ReadOnly setting in VolumeMounts. Default false.
          readOnly: null
        # PhotonPersistentDisk represents a PhotonController persistent disk
        # attached and mounted on kubelets host machine
        photonPersistentDisk:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified.
          fsType: null
          # ID that identifies Photon Controller persistent disk
          pdID: null
        # PortworxVolume represents a portworx volume attached and mounted on
        # kubelets host machine
        portworxVolume:
          # FSType represents the filesystem type to mount Must be a filesystem
          # type supported by the host operating system. Ex. "ext4", "xfs".
          # Implicitly inferred to be "ext4" if unspecified.
          fsType: null
          # Defaults to false (read/write). ReadOnly here will force the
          # ReadOnly setting in VolumeMounts.
          readOnly: null
          # VolumeID uniquely identifies a Portworx volume
          volumeID: null
        # Items for all in one resources secrets, configmaps, and downward API
        projected:
          # Mode bits used to set permissions on created files by default. Must
          # be an octal value between 0000 and 0777 or a decimal value between 0
          # and 511. YAML accepts both octal and decimal values, JSON requires
          # decimal values for mode bits. Directories within the path are not
          # affected by this setting. This might be in conflict with other
          # options that affect the file mode, like fsGroup, and the result can
          # be other mode bits set.
          defaultMode: null
          # list of volume projections
          sources:
            # information about the configMap data to project
            configMap:
              # If unspecified, each key-value pair in the Data field of the
              # referenced ConfigMap will be projected into the volume as a file
              # whose name is the key and content is the value. If specified,
              # the listed keys will be projected into the specified paths, and
              # unlisted keys will not be present. If a key is specified which
              # is not present in the ConfigMap, the volume setup will error
              # unless it is marked optional. Paths must be relative and may not
              # contain the '..' path or start with '..'.
              items:
                # The key to project.
                key: null
                # Optional: mode bits used to set permissions on this file. Must
                # be an octal value between 0000 and 0777 or a decimal value
                # between 0 and 511. YAML accepts both octal and decimal values,
                # JSON requires decimal values for mode bits. If not specified,
                # the volume defaultMode will be used. This might be in conflict
                # with other options that affect the file mode, like fsGroup,
                # and the result can be other mode bits set.
                mode: null
                # The relative path of the file to map the key to. May not be an
                # absolute path. May not contain the path element '..'. May not
                # start with the string '..'.
                path: null
              # Name of the referent. More info:
              # https://kubernetes.io/docs/concepts/overview/working-with-
              # objects/names/#names TODO: Add other useful fields. apiVersion,
              # kind, uid?
              name: null
              # Specify whether the ConfigMap or its keys must be defined
              optional: null
            # information about the downwardAPI data to project
            downwardAPI:
              # Items is a list of DownwardAPIVolume file
              items:
                # Required: Selects a field of the pod: only annotations,
                # labels, name and namespace are supported.
                fieldRef:
                  # Version of the schema the FieldPath is written in terms of,
                  # defaults to "v1".
                  apiVersion: null
                  # Path of the field to select in the specified API version.
                  fieldPath: null
                # Optional: mode bits used to set permissions on this file, must
                # be an octal value between 0000 and 0777 or a decimal value
                # between 0 and 511. YAML accepts both octal and decimal values,
                # JSON requires decimal values for mode bits. If not specified,
                # the volume defaultMode will be used. This might be in conflict
                # with other options that affect the file mode, like fsGroup,
                # and the result can be other mode bits set.
                mode: null
                # Required: Path is  the relative path name of the file to be
                # created. Must not be absolute or contain the '..' path. Must
                # be utf-8 encoded. The first item of the relative path must not
                # start with '..'
                path: null
                # Selects a resource of the container: only resources limits and
                # requests (limits.cpu, limits.memory, requests.cpu and
                # requests.memory) are currently supported.
                resourceFieldRef:
                  # Container name: required for volumes, optional for env vars
                  containerName: null
                  # Specifies the output format of the exposed resources,
                  # defaults to "1"
                  divisor: null
                  # Required: resource to select
                  resource: null
            # information about the secret data to project
            secret:
              # If unspecified, each key-value pair in the Data field of the
              # referenced Secret will be projected into the volume as a file
              # whose name is the key and content is the value. If specified,
              # the listed keys will be projected into the specified paths, and
              # unlisted keys will not be present. If a key is specified which
              # is not present in the Secret, the volume setup will error unless
              # it is marked optional. Paths must be relative and may not
              # contain the '..' path or start with '..'.
              items:
                # The key to project.
                key: null
                # Optional: mode bits used to set permissions on this file. Must
                # be an octal value between 0000 and 0777 or a decimal value
                # between 0 and 511. YAML accepts both octal and decimal values,
                # JSON requires decimal values for mode bits. If not specified,
                # the volume defaultMode will be used. This might be in conflict
                # with other options that affect the file mode, like fsGroup,
                # and the result can be other mode bits set.
                mode: null
                # The relative path of the file to map the key to. May not be an
                # absolute path. May not contain the path element '..'. May not
                # start with the string '..'.
                path: null
              # Name of the referent. More info:
              # https://kubernetes.io/docs/concepts/overview/working-with-
              # objects/names/#names TODO: Add other useful fields. apiVersion,
              # kind, uid?
              name: null
              # Specify whether the Secret or its key must be defined
              optional: null
            # information about the serviceAccountToken data to project
            serviceAccountToken:
              # Audience is the intended audience of the token. A recipient of a
              # token must identify itself with an identifier specified in the
              # audience of the token, and otherwise should reject the token.
              # The audience defaults to the identifier of the apiserver.
              audience: null
              # ExpirationSeconds is the requested duration of validity of the
              # service account token. As the token approaches expiration, the
              # kubelet volume plugin will proactively rotate the service
              # account token. The kubelet will start trying to rotate the token
              # if the token is older than 80 percent of its time to live or if
              # the token is older than 24 hours.Defaults to 1 hour and must be
              # at least 10 minutes.
              expirationSeconds: null
              # Path is the path relative to the mount point of the file to
              # project the token into.
              path: null
        # Quobyte represents a Quobyte mount on the host that shares a pod's
        # lifetime
        quobyte:
          # Group to map volume access to Default is no group
          group: null
          # ReadOnly here will force the Quobyte volume to be mounted with read-
          # only permissions. Defaults to false.
          readOnly: null
          # Registry represents a single or multiple Quobyte Registry services
          # specified as a string as host:port pair (multiple entries are
          # separated with commas) which acts as the central registry for
          # volumes
          registry: null
          # Tenant owning the given Quobyte volume in the Backend Used with
          # dynamically provisioned Quobyte volumes, value is set by the plugin
          tenant: null
          # User to map volume access to Defaults to serivceaccount user
          user: null
          # Volume is a string that references an already created Quobyte volume
          # by name.
          volume: null
        # RBD represents a Rados Block Device mount on the host that shares a
        # pod's lifetime. More info:
        # https://examples.k8s.io/volumes/rbd/README.md
        rbd:
          # Filesystem type of the volume that you want to mount. Tip: Ensure
          # that the filesystem type is supported by the host operating system.
          # Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
          # unspecified. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do
          # we prevent errors in the filesystem from compromising the machine
          fsType: null
          # The rados image name. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          image: null
          # Keyring is the path to key ring for RBDUser. Default is
          # /etc/ceph/keyring. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          keyring: null
          # A collection of Ceph monitors. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          monitors: null
          # The rados pool name. Default is rbd. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          pool: null
          # ReadOnly here will force the ReadOnly setting in VolumeMounts.
          # Defaults to false. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          readOnly: null
          # SecretRef is name of the authentication secret for RBDUser. If
          # provided overrides keyring. Default is nil. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # The rados user name. Default is admin. More info:
          # https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
          user: null
        # ScaleIO represents a ScaleIO persistent volume attached and mounted on
        # Kubernetes nodes.
        scaleIO:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
          fsType: null
          # The host address of the ScaleIO API Gateway.
          gateway: null
          # The name of the ScaleIO Protection Domain for the configured
          # storage.
          protectionDomain: null
          # Defaults to false (read/write). ReadOnly here will force the
          # ReadOnly setting in VolumeMounts.
          readOnly: null
          # SecretRef references to the secret for ScaleIO user and other
          # sensitive information. If this is not provided, Login operation will
          # fail.
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # Flag to enable/disable SSL communication with Gateway, default false
          sslEnabled: null
          # Indicates whether the storage for a volume should be
          # ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
          storageMode: null
          # The ScaleIO Storage Pool associated with the protection domain.
          storagePool: null
          # The name of the storage system as configured in ScaleIO.
          system: null
          # The name of a volume already created in the ScaleIO system that is
          # associated with this volume source.
          volumeName: null
        # Secret represents a secret that should populate this volume. More
        # info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        secret:
          # Optional: mode bits used to set permissions on created files by
          # default. Must be an octal value between 0000 and 0777 or a decimal
          # value between 0 and 511. YAML accepts both octal and decimal values,
          # JSON requires decimal values for mode bits. Defaults to 0644.
          # Directories within the path are not affected by this setting. This
          # might be in conflict with other options that affect the file mode,
          # like fsGroup, and the result can be other mode bits set.
          defaultMode: null
          # If unspecified, each key-value pair in the Data field of the
          # referenced Secret will be projected into the volume as a file whose
          # name is the key and content is the value. If specified, the listed
          # keys will be projected into the specified paths, and unlisted keys
          # will not be present. If a key is specified which is not present in
          # the Secret, the volume setup will error unless it is marked
          # optional. Paths must be relative and may not contain the '..' path
          # or start with '..'.
          items:
            # The key to project.
            key: null
            # Optional: mode bits used to set permissions on this file. Must be
            # an octal value between 0000 and 0777 or a decimal value between 0
            # and 511. YAML accepts both octal and decimal values, JSON requires
            # decimal values for mode bits. If not specified, the volume
            # defaultMode will be used. This might be in conflict with other
            # options that affect the file mode, like fsGroup, and the result
            # can be other mode bits set.
            mode: null
            # The relative path of the file to map the key to. May not be an
            # absolute path. May not contain the path element '..'. May not
            # start with the string '..'.
            path: null
          # Specify whether the Secret or its keys must be defined
          optional: null
          # Name of the secret in the pod's namespace to use. More info:
          # https://kubernetes.io/docs/concepts/storage/volumes#secret
          secretName: null
        # StorageOS represents a StorageOS volume attached and mounted on
        # Kubernetes nodes.
        storageos:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified.
          fsType: null
          # Defaults to false (read/write). ReadOnly here will force the
          # ReadOnly setting in VolumeMounts.
          readOnly: null
          # SecretRef specifies the secret to use for obtaining the StorageOS
          # API credentials.  If not specified, default values will be
          # attempted.
          secretRef:
            # Name of the referent. More info:
            # https://kubernetes.io/docs/concepts/overview/working-with-
            # objects/names/#names TODO: Add other useful fields. apiVersion,
            # kind, uid?
            name: null
          # VolumeName is the human-readable name of the StorageOS volume.
          # Volume names are only unique within a namespace.
          volumeName: null
          # VolumeNamespace specifies the scope of the volume within StorageOS.
          # If no namespace is specified then the Pod's namespace will be used.
          # This allows the Kubernetes name scoping to be mirrored within
          # StorageOS for tighter integration. Set VolumeName to any name to
          # override the default behaviour. Set to "default" if you are not
          # using namespaces within StorageOS. Namespaces that do not pre-exist
          # within StorageOS will be created.
          volumeNamespace: null
        # VsphereVolume represents a vSphere volume attached and mounted on
        # kubelets host machine
        vsphereVolume:
          # Filesystem type to mount. Must be a filesystem type supported by the
          # host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly
          # inferred to be "ext4" if unspecified.
          fsType: null
          # Storage Policy Based Management (SPBM) profile ID associated with
          # the StoragePolicyName.
          storagePolicyID: null
          # Storage Policy Based Management (SPBM) profile name.
          storagePolicyName: null
          # Path that identifies vSphere volume vmdk
          volumePath: null
  # Resources are the resource requirements for the Couchbase server container.
  # This field overrides any automatic allocation as defined by
  # `spec.autoResourceAllocation`.
  resources:
    # Limits describes the maximum amount of compute resources allowed. More
    # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
    # resources-container/
    limits: null
    # Requests describes the minimum amount of compute resources required. If
    # Requests is omitted for a container, it defaults to Limits if that is
    # explicitly specified, otherwise to an implementation-defined value. More
    # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
    # resources-container/
    requests: null
  # ServerGroups define the set of availability zones you want to distribute
  # pods over, and construct Couchbase server groups for.  By default, most
  # cloud providers will label nodes with the key "failure-
  # domain.beta.kubernetes.io/zone", the values associated with that key are
  # used here to provide explicit scheduling by the Operator.  You may manually
  # label nodes using the "failure-domain.beta.kubernetes.io/zone" key, to
  # provide failure-domain aware scheduling when none is provided for you.
  # Global server groups are applied to all server classes, and may be
  # overridden on a per-server class basis to give more control over scheduling
  # and server groups.
  serverGroups: null
  # Services is the set of Couchbase services to run on this server class. At
  # least one class must contain the data service.  The field may contain any of
  # "data", "index", "query", "search", "eventing" or "analytics". Each service
  # may only be specified once.
  services: null
  # Size is the expected requested of the server class.  This field must be
  # greater than or equal to 1.
  size: null
  # VolumeMounts define persistent volume claims to attach to pod.
  volumeMounts:
    # AnalyticsClaims are persistent volumes that encompass analytics storage
    # associated with the analytics service.  Analytics claims can only be used
    # on server classes running the analytics service, and must be used in
    # conjunction with the default claim. This field allows the analytics
    # service to use different storage media (e.g. SSD), and scale horizontally,
    # to improve performance of this service.  This field references a volume
    # claim template name as defined in "spec.volumeClaimTemplates".
    analytics: null
    # DataClaim is a persistent volume that encompasses key/value storage
    # associated with the data service.  The data claim can only be used on
    # server classes running the data service, and must be used in conjunction
    # with the default claim.  This field allows the data service to use
    # different storage media (e.g. SSD) to improve performance of this service.
    # This field references a volume claim template name as defined in
    # "spec.volumeClaimTemplates".
    data: null
    # DefaultClaim is a persistent volume that encompasses all Couchbase
    # persistent data, including document storage, indexes and logs.  The
    # default volume can be used with any server class.  Use of the default
    # claim allows the Operator to recover failed pods from the persistent
    # volume far quicker than if the pod were using ephemeral storage.  The
    # default claim cannot be used at the same time as the logs claim within the
    # same server class.  This field references a volume claim template name as
    # defined in "spec.volumeClaimTemplates".
    default: null
    # IndexClaim s a persistent volume that encompasses index storage associated
    # with the index and search services.  The index claim can only be used on
    # server classes running the index or search services, and must be used in
    # conjunction with the default claim.  This field allows the index and/or
    # search service to use different storage media (e.g. SSD) to improve
    # performance of this service. This field references a volume claim template
    # name as defined in "spec.volumeClaimTemplates". Whilst this references
    # index primarily, note that the full text search (FTS) service also uses
    # this same mount.
    index: null
    # LogsClaim is a persistent volume that encompasses only Couchbase server
    # logs to aid with supporting the product.  The logs claim can only be used
    # on server classes running the following services: query, search &
    # eventing.  The logs claim cannot be used at the same time as the default
    # claim within the same server class.  This field references a volume claim
    # template name as defined in "spec.volumeClaimTemplates". Whilst the logs
    # claim can be used with the search service, the recommendation is to use
    # the default claim for these. The reason for this is that a failure of
    # these nodes will require indexes to be rebuilt and subsequent performance
    # impact.
    logs: null
# SoftwareUpdateNotifications enables software update notifications in the UI.
# When enabled, the UI will alert when a Couchbase server upgrade is available.
softwareUpdateNotifications: null
# UpgradeStrategy controls how aggressive the Operator is when performing a
# cluster upgrade.  When a rolling upgrade is requested, pods are upgraded one
# at a time.  This strategy is slower, however less disruptive.  When an
# immediate upgrade strategy is requested, all pods are upgraded at the same
# time.  This strategy is faster, but more disruptive.  This field must be
# either "RollingUpgrade" or "ImmediateUpgrade", defaulting to "RollingUpgrade".
upgradeStrategy: null
# VolumeClaimTemplates define the desired characteristics of a volume that can
# be requested/claimed by a pod, for example the storage class to use and the
# volume size.  Volume claim templates are referred to by name by server class
# volume mount configuration.
volumeClaimTemplates:
  # Standard objects metadata.  This is a curated version for use with Couchbase
  # resource templates.
  metadata:
    # Annotations is an unstructured key value map stored with a resource that
    # may be set by external tools to store and retrieve arbitrary metadata.
    # They are not queryable and should be preserved when modifying objects.
    # More info: http://kubernetes.io/docs/user-guide/annotations
    annotations: null
    # Map of string keys and values that can be used to organize and categorize
    # (scope and select) objects. May match selectors of replication controllers
    # and services. More info: http://kubernetes.io/docs/user-guide/labels
    labels: null
    # Name must be unique within a namespace. Is required when creating
    # resources, although some resources may allow a client to request the
    # generation of an appropriate name automatically. Name is primarily
    # intended for creation idempotence and configuration definition. Cannot be
    # updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
    name: null
  # PersistentVolumeClaimSpec describes the common attributes of storage devices
  # and allows a Source for provider-specific attributes
  spec:
    # AccessModes contains the desired access modes the volume should have. More
    # info: https://kubernetes.io/docs/concepts/storage/persistent-
    # volumes#access-modes-1
    accessModes: null
    # Resources represents the minimum resources the volume should have. More
    # info: https://kubernetes.io/docs/concepts/storage/persistent-
    # volumes#resources
    resources:
      # Limits describes the maximum amount of compute resources allowed. More
      # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
      # resources-container/
      limits: null
      # Requests describes the minimum amount of compute resources required. If
      # Requests is omitted for a container, it defaults to Limits if that is
      # explicitly specified, otherwise to an implementation-defined value. More
      # info: https://kubernetes.io/docs/concepts/configuration/manage-compute-
      # resources-container/
      requests: null
    # A label query over volumes to consider for binding.
    selector:
      # matchExpressions is a list of label selector requirements. The
      # requirements are ANDed.
      matchExpressions:
        # key is the label key that the selector applies to.
        key: null
        # operator represents a key's relationship to a set of values. Valid
        # operators are In, NotIn, Exists and DoesNotExist.
        operator: null
        # values is an array of string values. If the operator is In or NotIn,
        # the values array must be non-empty. If the operator is Exists or
        # DoesNotExist, the values array must be empty. This array is replaced
        # during a strategic merge patch.
        values: null
      # matchLabels is a map of {key,value} pairs. A single {key,value} in the
      # matchLabels map is equivalent to an element of matchExpressions, whose
      # key field is "key", the operator is "In", and the values array contains
      # only "value". The requirements are ANDed.
      matchLabels: null
    # Name of the StorageClass required by the claim. More info:
    # https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    storageClassName: null
    # volumeMode defines what type of volume is required by the claim. Value of
    # Filesystem is implied when not included in claim spec.
    volumeMode: null
    # VolumeName is the binding reference to the PersistentVolume backing this
    # claim.
    volumeName: null
# XDCR defines whether the Operator should manage XDCR, remote clusters and how
# to lookup replication resources.
xdcr:
  # Managed defines whether XDCR is managed by the operator or not.
  managed: null
  # RemoteClusters is a set of named remote clusters to establish replications
  # to.
  remoteClusters:
    # AuthenticationSecret is a secret used to authenticate when establishing a
    # remote connection.  It is only required when not using mTLS.  The secret
    # must contain a username (secret key "username") and password (secret key
    # "password").
    authenticationSecret: null
    # Hostname is the connection string to use to connect the remote cluster.
    hostname: null
    # Name of the remote cluster.
    name: null
    # Replications are replication streams from this cluster to the remote one.
    # This field defines how to look up CouchbaseReplication resources.  By
    # default any CouchbaseReplication resources in the namespace will be
    # considered.
    replications:
      # Selector allows CouchbaseReplication resources to be filtered based on
      # labels.
      selector:
        # matchExpressions is a list of label selector requirements. The
        # requirements are ANDed.
        matchExpressions:
          # key is the label key that the selector applies to.
          key: null
          # operator represents a key's relationship to a set of values. Valid
          # operators are In, NotIn, Exists and DoesNotExist.
          operator: null
          # values is an array of string values. If the operator is In or NotIn,
          # the values array must be non-empty. If the operator is Exists or
          # DoesNotExist, the values array must be empty. This array is replaced
          # during a strategic merge patch.
          values: null
        # matchLabels is a map of {key,value} pairs. A single {key,value} in the
        # matchLabels map is equivalent to an element of matchExpressions, whose
        # key field is "key", the operator is "In", and the values array
        # contains only "value". The requirements are ANDed.
        matchLabels: null
    # TLS if specified references a resource containing the necessary
    # certificate data for an encrypted connection.
    tls:
      # Secret references a secret containing the CA certificate (data key
      # "ca"), and optionally a client certificate (data key "certificate") and
      # key (data key "key").
      secret: null
    # UUID of the remote cluster.  The UUID of a CouchbaseCluster resource is
    # advertised in the status.clusterId field of the resource.
    uuid: null
